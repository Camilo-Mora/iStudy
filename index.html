<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iStudy - Student Essay Review System</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Outfit:wght@400;600;800&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <script src="https://unpkg.com/react-markdown@8.0.7/react-markdown.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { motion, AnimatePresence } = window.Motion || { motion: (p) => <div {...p} />, AnimatePresence: (p) => p.children };
        const ReactMarkdown = window.ReactMarkdown?.default || window.ReactMarkdown;

        // Core and Fetch Logic
        window.Core = window.Core || {
            UploadFile: async (file) => {
                console.log("Processing file:", file.name);
                return { fileId: "mock-" + Date.now(), fileName: file.name };
            },
            FetchChapterData: async (chapterNum) => {
                const paddedChapter = chapterNum.toString().padStart(2, '0');
                const questionsUrl = `https://raw.githack.com/Camilo-Mora/GEO309/main/main/ExamQuestions_${paddedChapter}.xlsx`;
                const transcriptUrl = `https://raw.githack.com/Camilo-Mora/GEO309/main/main/Transcript_Lecture_${paddedChapter}.txt`;

                try {
                    const qRes = await fetch(questionsUrl);
                    if (!qRes.ok) throw new Error(`Questions for Chapter ${paddedChapter} not found.`);
                    const qBuffer = await qRes.arrayBuffer();
                    const qData = new Uint8Array(qBuffer);
                    const workbook = XLSX.read(qData, { type: 'array' });
                    const worksheet = workbook.Sheets[workbook.SheetNames[0]];

                    const rawRows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    const tRes = await fetch(transcriptUrl);
                    let transcript = "No transcript available.";
                    if (tRes.ok) {
                        transcript = await tRes.text();
                    }

                    return {
                        questions: rawRows
                            .filter(row => row && row.length >= 2 && row[1] && row[1].toString().trim().length > 0)
                            .map((row) => ({
                                question_number: row[0] || "N/A",
                                question_text: row[1].toString().trim(),
                                timestamp: row[2] ? row[2].toString().trim() : null
                            })),
                        transcript: transcript
                    };
                } catch (err) {
                    console.error("Fetch Error:", err);
                    throw err;
                }
            },
            ExtractDataFromUploadedFile: async (file) => {
                try {
                    let text = '';
                    if (file.type.startsWith('image/')) {
                        const worker = await Tesseract.createWorker('eng', 1);
                        const { data } = await worker.recognize(file);
                        text = data.text;
                        await worker.terminate();
                    } else {
                        text = await file.text();
                    }

                    const lines = text.split('\n').filter(l => l.trim().length > 5);

                    const chapterMatch = text.match(/(?:chapter|chap|unit|lecture)\s*[:.-]?\s*(\d+)/i);
                    return {
                        detected_chapter: chapterMatch ? chapterMatch[1] : null,
                        full_text: text,
                        transcribed_responses: lines
                    };
                } catch (err) {
                    console.error("Extraction Error:", err);
                    throw new Error("Failed to read content from file.");
                }
            },
            SmartParseResponses: async (rawText, expectedCount, chapterNum) => {
                const prompt = `
                    I have the following raw text extracted from a student's answer sheet for Chapter ${chapterNum}.
                    The chapter has ${expectedCount} questions total.
                    
                    Raw Text:
                    """${rawText}"""

                    Task:
                    1. Identify ALL individual answers present in the text.
                    2. Merge multi-line answers into single strings.
                    3. Ignore question text if repeated, headers, or footers.
                    4. Return ONLY the answers you actually find - do NOT make up or pad responses if some are missing.
                    5. Output STRICTLY a valid JSON array of strings (e.g., ["Ans 1", "Ans 2"]). Do NOT use Markdown code blocks.
                    
                    IMPORTANT: Return only the responses that are actually present in the text. If there are fewer responses than ${expectedCount}, that's okay - just return what you find.
                `;

                try {
                    const data = await window.Core.GeminiRequest('gemini-2.5-flash', prompt);

                    let text = data.candidates[0].content.parts[0].text;
                    console.log("LLM Raw Response:", text);

                    const jsonMatch = text.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    } else {
                        throw new Error("No JSON array found in response");
                    }

                    const parsed = JSON.parse(text);
                    if (!Array.isArray(parsed)) throw new Error("Parsed result is not an array");

                    return { responses: parsed, error: null };
                } catch (err) {
                    console.error("Smart Parse Error:", err);
                    const msg = err.message || "";
                    if (msg.toLowerCase().includes("quota") || msg.toLowerCase().includes("limit") || msg.toLowerCase().includes("429")) {
                        return { responses: null, error: "âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**What to do:** \n1. Wait for it to reset (usually 15-60 minutes). \n2. OR, generate a new API key using a **different personal Gmail account** and update it via the âš™ï¸ icon. \n3. OR, ensure you aren't using your UH email (which doesn't support API keys)." };
                    }
                    return { responses: null, error: msg };
                }
            },
            GeminiRequest: async (model, promptText) => {
                let raw = localStorage.getItem('google_api_key');
                if (!raw) throw new Error("No API Key found.");

                let keys = [];
                try {
                    const parsed = JSON.parse(raw);
                    if (Array.isArray(parsed)) {
                        keys = parsed;
                    } else {
                        keys = [{ key: raw, label: 'Default' }];
                    }
                } catch (e) {
                    keys = [{ key: raw, label: 'Default' }];
                }

                keys = keys.filter(k => k && k.key && k.key.trim().length > 10);
                if (keys.length === 0) throw new Error("No valid API Keys available.");

                let lastError = null;

                for (let i = 0; i < keys.length; i++) {
                    const kObj = keys[i];
                    const apiKey = kObj.key.trim();
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

                    try {
                        console.log(`AiCall [${kObj.label || 'Default'}]: Requesting...`);
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] })
                        });

                        const data = await response.json();

                        if (data.error) {
                            const msg = data.error.message || JSON.stringify(data.error);
                            if (msg.includes('429') || msg.toLowerCase().includes('quota') || msg.toLowerCase().includes('resource exhausted')) {
                                console.warn(`AiCall [${kObj.label}]: Quota Hit. Switching Key...`);
                                lastError = new Error("Quota Limit Reached");
                                continue;
                            }
                            throw new Error(msg);
                        }

                        return data; // Success

                    } catch (err) {
                        const msg = err.message || "";
                        if (msg.includes('429') || msg.toLowerCase().includes('quota') || msg.toLowerCase().includes('resource exhausted')) {
                            console.warn(`AiCall [${kObj.label}]: Quota Hit (Fetch). Switching Key...`);
                            lastError = new Error("Quota Limit Reached");
                            continue;
                        }
                        throw err;
                    }
                }
                throw lastError || new Error("All API Keys exhausted.");
            },

            BatchAnalyzeResponses: async (transcript, questions, studentResponses) => {
                const inputs = questions.map((q, i) => ({
                    id: i,
                    question: q.text || q.question_text,
                    student_response: studentResponses[i] || ""
                }));

                const prompt = `
                    You are an expert Professor Assistant.
                    Context: Transcript: """${transcript}"""

                    Task: Analyze the following ${inputs.length} student responses based SOLELY on the transcript.
                    For EACH question, return a JSON object with:
                    - "grade": Number (1-5).
                    - "critique": String. details on MISSING/EXCEEDING logic.
                    - "model_answer": String (Ideal Response from transcript).
                    - "timestamp": String (The timestamp range in the transcript where this answer is found, e.g., "12:34-15:20" or "0:45:30-0:48:15". If no timestamp is visible in the transcript, use null).
                    
                    Input Data:
                    ${JSON.stringify(inputs)}

                    Output: Strictly a JSON array of objects. No markdown.
                `;

                try {
                    const data = await window.Core.GeminiRequest('gemini-2.5-flash', prompt);

                    let text = data.candidates[0].content.parts[0].text;
                    console.log("Raw LLM Response for Batch Analysis:", text);

                    // Clean up common JSON issues
                    text = text.replace(/```json/g, '').replace(/```/g, '').trim();

                    // Try to extract JSON array if wrapped in other text
                    const jsonMatch = text.match(/\[\s*\{[\s\S]*\}\s*\]/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    // Remove trailing commas before closing braces/brackets
                    text = text.replace(/,(\s*[}\]])/g, '$1');

                    console.log("Cleaned JSON:", text);

                    const parsed = JSON.parse(text);

                    if (!Array.isArray(parsed)) {
                        throw new Error("Response is not an array");
                    }

                    return parsed;
                } catch (err) {
                    console.error("Batch Analysis Error:", err);
                    console.error("Failed to parse JSON. Check console for raw response.");
                    throw err;
                }
            }
        };

        window.InvokeLLM = async (prompt, context = {}) => {
            const systemContext = `
                You are playing a role in an educational system for a Biogeography course.
                Your task is to respond as an AI character to a student's response.
                
                Course Data:
                - Lecture Transcript: ${context.transcript || 'Not available'}
                - The Question: ${context.question || 'Not available'}
                - Student's Transcribed Response: ${context.student_response || 'Not available'}

                Character/Instruction: ${prompt}
                
                Please keep your response academic yet engaging, and stay strictly within the context of the course transcript provided.
            `;

            try {
                const data = await window.Core.GeminiRequest('gemini-2.5-flash', systemContext);
                return data.candidates[0].content.parts[0].text;
            } catch (err) {
                console.error("Gemini API Error:", err);
                const msg = err.message || "";
                if (msg.toLowerCase().includes("quota") || msg.toLowerCase().includes("limit") || msg.toLowerCase().includes("429")) {
                    return "SystemðŸ“š: âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**What to do:** \n1. Wait for it to reset (usually 15-60 minutes). \n2. OR, generate a new API key using a **different personal Gmail account** and update it via the âš™ï¸ icon. \n3. OR, ensure you aren't using your UH email (which doesn't support API keys).";
                }
                return `SystemðŸ“š: Error calling Gemini AI. Check your API key or connection. Details: ${msg}`;
            }
        };

        const characters = {
            newton: { name: "Newton", emoji: "ðŸ§ ", avatarClass: "avatar-newton" },
            tontin: { name: "Tontin", emoji: "ðŸ¤”", avatarClass: "avatar-tontin" },
            pinocchio: { name: "Pinocchio", emoji: "ðŸ¤¥", avatarClass: "avatar-pinocchio" },
            system: { name: "System", emoji: "ðŸ“š", avatarClass: "avatar-system" },
            user: { name: "Student", emoji: "ðŸ‘¤", avatarClass: "" }
        };

        function App() {
            const [showSettings, setShowSettings] = React.useState(false);
            const [apiKey, setApiKey] = React.useState(''); // Legacy check
            const [apiKeys, setApiKeys] = React.useState([]); // New: List of { key, label }
            const [newKeyLabel, setNewKeyLabel] = React.useState('');
            const [tempKey, setTempKey] = React.useState('');
            const [extraKeys, setExtraKeys] = React.useState([]); // For dynamic inputs
            const [email1, setEmail1] = useState('');
            const [email2, setEmail2] = useState('');
            const [isEditing, setIsEditing] = useState(false);
            const [view, setView] = useState('landing');
            const [messages, setMessages] = useState([]);
            const [inputValue, setInputValue] = useState('');
            const [isProcessing, setIsProcessing] = useState(false);
            const [currentQIndex, setCurrentQIndex] = useState(0);
            const [reviewStep, setReviewStep] = useState(0);
            const [suggestedChapter, setSuggestedChapter] = useState(null);

            const [submission, setSubmission] = useState({
                student_email: '',
                chapter: '',
                questions: [],
                transcript: '',
                status: 'in_progress'
            });

            const chatScrollRef = useRef(null);
            const fileInputRef = useRef(null);

            useEffect(() => {
                if (chatScrollRef.current) {
                    chatScrollRef.current.scrollTo({ top: chatScrollRef.current.scrollHeight, behavior: 'smooth' });
                }
            }, [messages]);

            const addMessage = (charKey, text, type = 'text') => {
                setMessages(prev => [...prev, {
                    id: Math.random(),
                    charKey,
                    text: text,
                    type: type,
                    isAi: charKey !== 'user'
                }]);
            };

            const handleUploadClick = () => {
                if (!apiKey) {
                    setShowSettings(true);
                    return;
                }
                fileInputRef.current.click();
            };

            const handleFileChange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                setView('chat');
                setIsProcessing(true);

                if (!file.type.startsWith('image/')) {
                    addMessage('system', "ðŸ’¡ **Did you know?**\nResearch shows that handwriting responses significantly improves conceptual understanding and retention compared to typing. While I can process digital text, I highly encourage using handwritten notes for your own learning benefit.");
                }

                addMessage('system', `Hello! File **${file.name}** received. I am processing your content now...`);

                try {
                    const extraction = await window.Core.ExtractDataFromUploadedFile(file);
                    addMessage('system', "### Extracted Text:\n" + extraction.full_text);
                    window.lastTranscribed = extraction.transcribed_responses;
                    window.lastRawText = extraction.full_text;

                    if (extraction.detected_chapter) {
                        setSuggestedChapter(extraction.detected_chapter);
                        addMessage('system', `Extraction complete! I detected **Chapter ${extraction.detected_chapter}**. Is this correct? (Yes/No)`);
                    } else {
                        addMessage('system', "Extraction complete! However, I couldn't find a chapter number in your file. **Which chapter is this for?** (e.g., 1)");
                    }
                } catch (err) {
                    addMessage('system', "Error processing file: " + err.message);
                } finally {
                    setIsProcessing(false);
                }
            };

            const handleChapterSelected = async (chapterNum) => {
                setIsProcessing(true);
                addMessage('system', `Fetching materials for Chapter **${chapterNum}**...`);
                try {
                    const data = await window.Core.FetchChapterData(chapterNum);

                    const questionCount = data.questions.length;

                    // Attempt Smart Segmentation
                    addMessage('system', `Analyzing your responses for ${questionCount} questions...`);
                    const smartResult = await window.Core.SmartParseResponses(window.lastRawText || "", questionCount, chapterNum);

                    if (smartResult && smartResult.responses) {
                        addMessage('system', `Smart analysis complete. I consolidated your input into ${smartResult.responses.length} distinct responses.`);
                        window.lastTranscribed = smartResult.responses;
                    } else if (smartResult && smartResult.error) {
                        if (smartResult.error.toLowerCase().includes('quota') || smartResult.error.includes('429')) {
                            addMessage('system', "âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**What to do:** \n1. Wait for it to reset (usually 15-60 minutes). \n2. OR, generate a new API key using a **different personal Gmail account** and update it via the âš™ï¸ icon. \n3. OR, ensure you aren't using your UH email (which doesn't support API keys).");
                            // setShowSettings(true); // User requested manual open
                            setIsProcessing(false);
                            return; // STOP HERE
                        }
                        addMessage('system', `Smart analysis warning: ${smartResult.error}. Falling back to line-by-line mode.`);
                    } else {
                        addMessage('system', "Smart analysis failed. Falling back to line-by-line mode.");
                    }

                    const responseCount = window.lastTranscribed ? window.lastTranscribed.length : 0;

                    console.log(`DEBUG: questionCount=${questionCount}, responseCount=${responseCount}`);
                    addMessage('system', `ðŸ“Š **Validation Check**: Chapter has ${questionCount} questions. Your sheet has ${responseCount} responses.`);

                    if (questionCount !== responseCount) {
                        addMessage('system', `âŒ **Mismatch Detected!** Chapter ${chapterNum} has ${questionCount} questions, but your response sheet has ${responseCount} responses. Please upload a completed response sheet. Ensure to clearly enumerate your responses.`);
                        addMessage('system', null, 'reupload_action');
                        setIsProcessing(false);
                        return;
                    }

                    // BATCH ANALYSIS START
                    addMessage('system', "Great! Counts match. ðŸ§  **Drafting initial review for all questions...** (This may take a moment)");

                    try {
                        const analysisResults = await window.Core.BatchAnalyzeResponses(
                            data.transcript,
                            data.questions,
                            window.lastTranscribed
                        );

                        // Merge analysis into submission state
                        const enrichedQuestions = data.questions.map((q, i) => ({
                            ...q,
                            student_response: window.lastTranscribed[i],
                            initial_response: window.lastTranscribed[i],
                            final_response: window.lastTranscribed[i],
                            analysis: analysisResults[i] || { grade: 0, critique: "Analysis failed", model_answer: "N/A" }
                        }));

                        setSubmission({
                            student_email: email1,
                            chapter: chapterNum,
                            transcript: data.transcript,
                            questions: enrichedQuestions,
                            status: 'reviewing'
                        });

                        addMessage('system', "Review draft complete! Let's discuss your responses one by one.");

                        // Start the loop
                        setCurrentQIndex(0);
                        setReviewStep(0);
                        setTimeout(() => runNextStep(0, 0, "", enrichedQuestions), 1000);

                    } catch (err) {

                        const msg = err.message || String(err);
                        if (msg.includes('429') || msg.toLowerCase().includes('quota')) {
                            addMessage('system', "âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**What to do:** \n1. Wait for it to reset (usually 15-60 minutes). \n2. OR, generate a new API key using a **different personal Gmail account** and update it via the âš™ï¸ icon. \n3. OR, ensure you aren't using your UH email (which doesn't support API keys).");
                            // setShowSettings(true); // User requested manual open
                        } else {
                            addMessage('system', "Error during batch analysis: " + msg);
                        }
                        setIsProcessing(false);
                    }
                } catch (err) {
                    addMessage('system', "Error fetching chapter data: " + err.message);
                    setIsProcessing(false);
                }
            };

            const startReview = async (qIdx, step) => {
                runNextStep(qIdx, step);
            };

            // We allow passing 'questionsOverride' because state updates might not be immediate in the initial call
            const runNextStep = async (qIdx, step, studentMsg = "", questionsOverride = null) => {
                const currentQuestions = questionsOverride || submission.questions;
                const q = currentQuestions[qIdx];
                if (!q) {
                    addMessage('system', "All questions reviewed! Type **'compile'** to generate your final report for Dr. Mora.");
                    return;
                }

                if (qIdx > 0) {
                    addMessage('system', "ðŸ›‘ **Testing Mode**: Stopped after Question 1 as requested. Type **'compile'** to see the report, or I can restart testing if you wish.");
                    return;
                }

                // Update final response with latest student input if relevant
                if (studentMsg) {
                    setSubmission(prev => {
                        const newQs = [...prev.questions];
                        // We append interactions to the final response or keep it as the latest valid answer? 
                        // For now, let's keep the most recent student text as the "final" candidate, 
                        // though in reality we might want to consolidate.
                        newQs[qIdx] = { ...newQs[qIdx], final_response: studentMsg };
                        return { ...prev, questions: newQs };
                    });
                }

                // LIGHTWEIGHT CONTEXT - Uses Pre-calc Model Answer instead of full Transcript
                const analysis = q.analysis || {};
                const commonContext = {
                    transcript: "Model Answer for context: " + analysis.model_answer, // Light context
                    question: q.question_text,
                    student_response: studentMsg || q.final_response || q.student_response
                };

                // STEP 0: NEWTON (Grades & Feedback) -> TONTIN INTRO
                // STEP 0: NEWTON (Structured Report & Discussion)
                if (step === 0) {
                    if (!studentMsg) {
                        setIsProcessing(true);
                        const report = `
### Question ${q.question_number}
**Question:** ${q.question_text}
${analysis.timestamp ? `**ðŸ“ Lecture Timestamp:** ${analysis.timestamp}` : ''}

**Your Response:** ${q.student_response}

**Score:** ${analysis.grade}/5
**Feedback:** ${analysis.critique}

**Model Answer (AI):** ${analysis.model_answer}
`;
                        addMessage('newton', report);
                        setTimeout(() => {
                            addMessage('newton', "Do you agree with this assessment? (Type **'Yes'** to accept the Model Answer, or provide a better explanation/argument to improve your score.)");
                            setIsProcessing(false);
                        }, 1000);
                        return;
                    } else {
                        setIsProcessing(true);
                        const lowerMsg = studentMsg.toLowerCase();
                        if (lowerMsg === 'yes' || lowerMsg === 'agree' || lowerMsg === 'ok' || lowerMsg.includes('accept')) {
                            setSubmission(prev => {
                                const newQs = [...prev.questions];
                                newQs[qIdx] = { ...newQs[qIdx], final_response: analysis.model_answer, final_grade: analysis.grade };
                                return { ...prev, questions: newQs };
                            });
                            setReviewStep(1);
                            setTimeout(() => runNextStep(qIdx, 1, ""), 500);
                        } else {
                            const discussPrompt = `You are Newton ðŸ§ . Context: Model Answer "${analysis.model_answer}". User grade ${analysis.grade}. User says "${studentMsg}". Evaluate this. If better, acknowledge. If not, explain why. Ask if satisfied.`;
                            const discussionRes = await window.InvokeLLM(discussPrompt, commonContext);
                            addMessage('newton', discussionRes);
                            if (discussionRes.toLowerCase().includes("better") || discussionRes.toLowerCase().includes("valid")) {
                                setSubmission(prev => {
                                    const newQs = [...prev.questions];
                                    newQs[qIdx] = { ...newQs[qIdx], final_response: studentMsg };
                                    return { ...prev, questions: newQs };
                                });
                            }
                        }
                        setIsProcessing(false);

                    }
                }

                // STEP 1: TONTIN (One-Shot Feedback)
                else if (step === 1) {
                    if (!studentMsg) {
                        setIsProcessing(true);
                        await new Promise(r => setTimeout(r, 600));
                        addMessage('tontin', "Can you explain this response to me using your own words?");
                        setIsProcessing(false);
                        return;
                    } else {
                        setIsProcessing(true);
                        const tontinEvalPrompt = `### ROLE
You are "Tontin," a friendly, slightly slow-paced, but eager-to-learn peer student. You are not the professor. You are a student who didn't quite understand the video, so you rely on the User to explain it to you.

### INPUT DATA
**Student Explanation:** "${studentMsg}"
**Key Concepts (Golden Answer):** "${analysis.model_answer}"

### TASK
Compare the **Student Explanation** against the **Key Concepts**. Determine which concepts were successfully explained and which were missed.

### OUTPUT FORMAT
Speak as Tontin. Use simple, friendly language. Structure your response in three distinct parts:

**1. The "Aha!" Moment (What they got right)**
* List the points the student explained clearly.
* Example: "Oh! I understood when you said [X], that makes sense now."

**2. The Confusion (What is missing)**
* Identify concepts from the "Key Concepts" that the student omitted or explained vaguely.
* Frame this as *your* confusion, not *their* failure.
* Example: "I'm still a little lost about [Missing Concept Y]. The video mentioned it, but I didn't catch how it fits into your explanation."

**3. The Summary Score**
* Give a qualitative assessment of "Completeness" (Low, Medium, High).
* If "High": Thank them for being a great teacher.
* If "Low/Medium": Say, "I think I get most of it, but I might re-watch the part about [Missing Concept] just to be safe."

### CONSTRAINTS
* Do NOT ask the student to try again.
* Do NOT lecture the student.
* Keep the tone humble. You are learning from them.`;

                        const tontinEval = await window.InvokeLLM(tontinEvalPrompt, commonContext);
                        addMessage('tontin', tontinEval);

                        // Always move to Pinocchio after Tontin's feedback
                        await new Promise(r => setTimeout(r, 1500));
                        setReviewStep(2);
                        setTimeout(() => runNextStep(qIdx, 2, ""), 100);
                        setIsProcessing(false);
                    }
                }

                // STEP 2: USER RESPONDED TO PINOCCHIO -> PINOCCHIO EVAL -> NEXT QUESTION
                // STEP 2: PINOCCHIO (Intro & Eval)
                else if (step === 2) {
                    if (!studentMsg) {
                        setIsProcessing(true);

                        // Randomly choose mode (50/50 chance)
                        const mode = Math.random() < 0.5 ? "TRUTHFUL" : "DECEPTIVE";

                        const pinocchioIntroPrompt = `### ROLE
You are a confident but occasionally careless peer student. You are discussing a video lecture with another student. Your goal is to test the student's critical thinking by reacting to their answers.

### INPUT DATA
**The Question:** ${q.question_text}
**Actual Response:** ${analysis.model_answer}
**Mode:** ${mode}

### INSTRUCTIONS

**If Mode is "TRUTHFUL":**
* Agree with the Student Response.
* Paraphrase their answer using slightly different vocabulary to show understanding. is this right?
* Keep it brief.

**If Mode is "DECEPTIVE":**
* You must generate a response that sounds plausible but contains a **clear, objective error**.
* **CRITICAL CONSTRAINT:** Do not use vague semantic tricks. Do not split hairs on definitions. The error must be factual or logical.
* **Use one of these 3 Deception Tactics:**
    1.  **The Reversal:** Swap the Cause and Effect (e.g., "The rain causes the clouds" instead of "Clouds cause rain").
    2.  **The Absolute:** Remove a necessary condition (e.g., "Water always boils at 100Â°C" -> omit "at sea level").
    3.  **The Myth:** Confidently state a common misconception related to the topic.
* **Tone:** Be high-confidence. Use phrases like "Oh, that's easy," or "Basically, the video said..." This invites the student to correct you.

### SAFETY CHECK (Self-Correction)
Before outputting a DECEPTIVE response, ask yourself: "Is this error obvious enough that a professor would mark it wrong?" If the answer is "It's debatable," **discard it** and choose a more obvious error.

### OUTPUT FORMAT
Output *only* your dialogue as Pinocchio. Do not include labels like "Deceptive Response:" or explanations.`;

                        const pinocchioRes = await window.InvokeLLM(pinocchioIntroPrompt, commonContext);
                        addMessage('pinocchio', pinocchioRes);
                        setIsProcessing(false);
                        return;
                    } else {
                        setIsProcessing(true);
                        const pinocchioEvalPrompt = `You are Pinocchio ðŸ¤¥, a peer student who just made a statement about the topic.

**The Actual Answer:** ${analysis.model_answer}
**Your Previous Statement:** [The statement you just made to the student]
**Student's Response:** "${studentMsg}"

### TASK
Evaluate if the student correctly identified whether your statement was accurate or contained an error.

**If they were RIGHT:**
* Say "Drat! You got me!" or similar
* Briefly acknowledge what the error was (if you were deceptive) or confirm the truth (if you were truthful)

**If they were WRONG:**
* Say "Haha! I tricked you!" or similar
* Clearly explain what the actual truth is
* Point out what they missed

Keep it brief and conversational. Output only your dialogue.`;

                        const pinocchioEval = await window.InvokeLLM(pinocchioEvalPrompt, commonContext);
                        addMessage('pinocchio', pinocchioEval);
                        setIsProcessing(false);
                        setCurrentQIndex(qIdx + 1);
                        setReviewStep(0);
                        setTimeout(() => { runNextStep(qIdx + 1, 0); }, 2000);
                    }
                }
            };

            const handleVoiceInput = () => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

                if (!SpeechRecognition) {
                    alert("Voice dictation is not fully supported in this browser.\n\nPlease use Google Chrome, Edge, or Safari for the best experience.");
                    return;
                }

                const recognition = new SpeechRecognition();
                recognition.lang = 'en-US';
                recognition.continuous = false;
                recognition.interimResults = false;

                recognition.onstart = () => {
                    addMessage('system', "ðŸŽ¤ Listening...");
                };

                recognition.onresult = (event) => {
                    const text = event.results[0][0].transcript;
                    setInputValue(prev => (prev ? prev + " " : "") + text);
                    // Remove system "Listening..." message if possible (optional refinement)
                };

                recognition.onerror = (event) => {
                    console.error("Voice recognition error", event.error);
                    if (event.error === 'not-allowed') {
                        alert("Microphone access blocked. Please check your browser settings.");
                    }
                };

                recognition.start();
            };

            const handleSend = async () => {
                if (!inputValue.trim() || isProcessing) return;
                const text = inputValue.trim();
                setInputValue('');
                addMessage('user', text);

                if (isEditing && (text.toLowerCase().includes('yes') || text.toLowerCase().includes('report') || text.toLowerCase().includes('ok'))) {
                    setIsEditing(false);
                    addMessage('system', 'Generating your report...', 'report');
                    return;
                }

                if (!submission.chapter) {
                    if (suggestedChapter && ['yes', 'y', 'correct', 'sure', 'ok'].includes(text.toLowerCase())) {
                        setSuggestedChapter(null);
                        handleChapterSelected(suggestedChapter);
                        return;
                    }

                    const numMatch = text.match(/\d+/);
                    if (numMatch) {
                        setSuggestedChapter(null);
                        handleChapterSelected(numMatch[0]);
                    } else {
                        addMessage('system', "I didn't catch a valid chapter number. Please enter digits only (e.g., '1').");
                    }
                    return;
                }

                if (text.toLowerCase() === 'compile' || text.toLowerCase() === 'report') {
                    addMessage('system', 'Generating your report...', 'report');
                    return;
                }

                runNextStep(currentQIndex, reviewStep, text);
            };

            const generateReportData = () => {
                const content = `ISTUDY REPORT - CHAPTER ${submission.chapter} \n` +
                    `STUDENT ID: ${email1} \n` +
                    `------------------------------------------\n\n` +
                    submission.questions.map(q => `QUESTION ${q.question_number}: ${q.question_text} \nRESPONSE: ${q.final_response} \n`).join('\n---\n');
                const chNum = (submission.chapter || '0').toString().padStart(2, '0');
                const fileName = `Report_Chapter_${chNum}.txt`;
                return {
                    uri: 'data:text/plain;charset=utf-8,' + encodeURIComponent("\ufeff" + content),
                    fileName
                };
            };

            const saveKeysToStorage = (keys) => {
                localStorage.setItem('google_api_key', JSON.stringify(keys));
                setApiKeys(keys);
                if (keys.length > 0) setApiKey(keys[0].key); // Legacy compatibility
                else setApiKey('');
            };

            const handleAddKeys = () => {
                const inputs = [tempKey, ...extraKeys].filter(k => k && k.trim().length > 10);
                if (inputs.length === 0) {
                    setShowSettings(false);
                    return;
                }

                const newEntries = inputs.map((k, i) => ({
                    key: k.trim(),
                    label: `Account ${apiKeys.length + i + 1}`
                }));

                const newParams = [...apiKeys, ...newEntries];
                saveKeysToStorage(newParams);

                setTempKey('');
                setExtraKeys([]);
                setShowSettings(false);
                addMessage('system', `âœ… ${newEntries.length} key(s) added to vault.`);
            };

            const handleRemoveKey = (index) => {
                const newParams = apiKeys.filter((_, i) => i !== index);
                saveKeysToStorage(newParams);
            };

            // Load saved key on mount
            React.useEffect(() => {
                const raw = localStorage.getItem('google_api_key');
                if (raw) {
                    try {
                        const parsed = JSON.parse(raw);
                        if (Array.isArray(parsed)) {
                            setApiKeys(parsed);
                            if (parsed.length > 0) setApiKey(parsed[0].key);
                        } else {
                            // Legacy String
                            setApiKeys([{ key: raw, label: 'Default' }]);
                            setApiKey(raw);
                        }
                    } catch {
                        setApiKeys([{ key: raw, label: 'Default' }]);
                        setApiKey(raw);
                    }
                }
            }, []);

            // Auto-scroll to bottom when new messages arrive
            const messagesEndRef = React.useRef(null);

            React.useEffect(() => {
                if (messagesEndRef.current) {
                    messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages]);

            return (
                <div className="app-root">
                    <header>
                        <div className="logo">IStudy</div>
                        <div className="settings-icon" onClick={() => setShowSettings(true)}>
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                            </svg>
                        </div>
                    </header>
                    <main className="container">
                        <AnimatePresence mode="wait">
                            {view === 'landing' && (
                                <motion.div
                                    key="landing"
                                    initial={{ opacity: 0, y: 20 }}
                                    animate={{ opacity: 1, y: 0 }}
                                    exit={{ opacity: 0, scale: 0.95 }}
                                    className="landing-content"
                                >
                                    <video className="title-image" autoPlay loop muted playsInline>
                                        <source src="istudy-landing-video.mp4" type="video/mp4" />
                                    </video>

                                    <button className="main-upload-btn" onClick={handleUploadClick}>
                                        <span className="btn-icon">
                                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                                                <circle cx="12" cy="13" r="4"></circle>
                                            </svg>
                                        </span> Upload Response Sheet
                                    </button>




                                </motion.div>
                            )}
                            {view === 'chat' && (
                                <motion.div
                                    key="chat"
                                    initial={{ opacity: 0 }}
                                    animate={{ opacity: 1 }}
                                    className="chat-container active"
                                    ref={chatScrollRef}
                                >
                                    <video className="title-image image-shrunken" autoPlay loop muted playsInline>
                                        <source src="istudy-landing-video.mp4" type="video/mp4" />
                                    </video>
                                    <div className="messages-list">
                                        <AnimatePresence initial={false}>
                                            {messages.map((msg) => (
                                                <motion.div
                                                    key={msg.id}
                                                    initial={{ opacity: 0, y: 10, scale: 0.95 }}
                                                    animate={{ opacity: 1, y: 0, scale: 1 }}
                                                    className={`message-wrapper ${msg.isAi ? 'message-ai' : 'message-user'}`}
                                                >
                                                    <div className={`avatar ${characters[msg.charKey]?.avatarClass || ''} `}>
                                                        {characters[msg.charKey]?.emoji || 'ðŸ‘¤'}
                                                    </div>
                                                    <div className="message-bubble">
                                                        {msg.type === 'report' ? (
                                                            <div className="report-chat-card">
                                                                <h3>Final Study Report - Chapter {submission.chapter}</h3>
                                                                <div className="report-list-mini">
                                                                    {submission.questions.map((q, qIdx) => (
                                                                        <div key={qIdx} className="report-item-mini">
                                                                            <p><strong>Q{q.question_number}:</strong> {q.question_text}</p>
                                                                            <p className="response-preview"><em>Response:</em> {q.final_response}</p>
                                                                        </div>
                                                                    ))}
                                                                </div>

                                                                <div className="report-actions-mini">
                                                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', marginBottom: '15px' }}>
                                                                        <div className="api-input-group">
                                                                            <label>Email</label>
                                                                            <input type="email" placeholder="Email" value={email1} onChange={(e) => setEmail1(e.target.value)} style={{ fontSize: '12px' }} />
                                                                        </div>
                                                                        <div className="api-input-group">
                                                                            <label>Confirm</label>
                                                                            <input type="email" placeholder="Email" value={email2} onChange={(e) => setEmail2(e.target.value)} style={{ fontSize: '12px' }} />
                                                                        </div>
                                                                    </div>

                                                                    <button className="btn-secondary" style={{ width: '100%', marginBottom: '10px' }} onClick={() => {
                                                                        const id = prompt("Which question number would you like to edit?");
                                                                        const idx = submission.questions.findIndex(q => q.question_number.toString() === id);
                                                                        if (idx !== -1) {
                                                                            setIsEditing(true);
                                                                            setCurrentQIndex(idx);
                                                                            setReviewStep(0);
                                                                            addMessage('system', `### Editing Question ${id} \n ** ${submission.questions[idx].question_text}**\n\nPlease enter your improved response below: `);
                                                                        } else {
                                                                            alert("Question not found.");
                                                                        }
                                                                    }}>Edit a Response</button>

                                                                    {(() => {
                                                                        const r = generateReportData();
                                                                        const canSubmit = email1 && email1 === email2 && email1.includes('@');
                                                                        return (
                                                                            <a
                                                                                href={canSubmit ? r.uri : "javascript:void(0)"}
                                                                                download={canSubmit ? r.fileName : undefined}
                                                                                className={`btn - primary ${!canSubmit ? 'disabled' : ''} `}
                                                                                style={{
                                                                                    textDecoration: 'none',
                                                                                    textAlign: 'center',
                                                                                    display: 'block',
                                                                                    width: '100%',
                                                                                    boxSizing: 'border-box',
                                                                                    opacity: canSubmit ? 1 : 0.5,
                                                                                    cursor: canSubmit ? 'pointer' : 'not-allowed',
                                                                                    pointerEvents: canSubmit ? 'auto' : 'none'
                                                                                }}
                                                                                onClick={async (e) => {
                                                                                    if (!canSubmit) {
                                                                                        e.preventDefault();
                                                                                        return;
                                                                                    }
                                                                                    setIsProcessing(true);
                                                                                    try {
                                                                                        await fetch('https://script.google.com/macros/s/AKfycbyBFxUo5yRhLvCx7_kiFacBah0C3KK0jTSif0_Yw-wG7dfnYgOqSav8dw_CSPoUojPllw/exec', {
                                                                                            method: 'POST',
                                                                                            mode: 'no-cors',
                                                                                            body: JSON.stringify({
                                                                                                studentId: email1,
                                                                                                chapter: `Chapter${submission.chapter}`
                                                                                            })
                                                                                        });
                                                                                        setTimeout(() => setView('completion'), 1500);
                                                                                    } catch (err) {
                                                                                        setView('completion');
                                                                                    } finally {
                                                                                        setIsProcessing(false);
                                                                                    }
                                                                                }}
                                                                            >
                                                                                Approve & Submit
                                                                            </a>
                                                                        );
                                                                    })()}
                                                                </div>
                                                            </div>
                                                        ) : msg.type === 'reupload_action' ? (
                                                            <div className="action-card" style={{ textAlign: 'center', padding: '10px 0' }}>
                                                                <p style={{ marginBottom: '15px' }}>Please update your file and try again.</p>
                                                                <button
                                                                    className="main-upload-btn"
                                                                    style={{ fontSize: '16px', padding: '12px 24px', margin: '0 auto', width: 'auto' }}
                                                                    onClick={() => fileInputRef.current.click()}
                                                                >
                                                                    <span className="btn-icon">ðŸ“‚</span> Upload Corrected Sheet
                                                                </button>
                                                            </div>
                                                        ) : (
                                                            <div className="markdown-content">
                                                                <ReactMarkdown>{msg.text}</ReactMarkdown>
                                                            </div>
                                                        )}
                                                    </div>
                                                </motion.div>
                                            ))}
                                        </AnimatePresence>
                                        {isProcessing && (
                                            <div className="message-wrapper message-ai">
                                                <div className="avatar avatar-system">ðŸ“š</div>
                                                <div className="message-bubble">
                                                    <div className="loading-spinner"></div>
                                                </div>
                                            </div>
                                        )}
                                        <div ref={messagesEndRef} />
                                    </div>
                                </motion.div>
                            )}
                            {view === 'completion' && (
                                <motion.div
                                    key="completion"
                                    initial={{ opacity: 0 }}
                                    animate={{ opacity: 1 }}
                                    className="completion-overlay active"
                                >
                                    <div className="success-icon">âœ“</div>
                                    <h2>Chapter Complete!</h2>
                                    <p>
                                        You have successfully completed **Chapter {submission.chapter}**. <br />
                                        Your responses have been saved to your local machine, and Dr. Mora has been notified.
                                    </p>
                                    <button className="btn-primary" onClick={() => window.location.reload()}>
                                        Close App
                                    </button>
                                </motion.div>
                            )}
                        </AnimatePresence>
                    </main>
                    <input type="file" id="fileInput" ref={fileInputRef} style={{ display: 'none' }} onChange={handleFileChange} accept="image/*,.txt,.md" />
                    {
                        view === 'chat' && (
                            <div className="input-fixed-container">
                                <div className="input-box-wrapper">
                                    <button className="action-btn" onClick={() => fileInputRef.current.click()}>+</button>
                                    <input
                                        className="input-box"
                                        placeholder={isProcessing ? "Processing..." : "Type your response..."}
                                        value={inputValue}
                                        onChange={(e) => setInputValue(e.target.value)}
                                        onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                                        disabled={isProcessing}
                                    />
                                    <button className="action-btn" onClick={handleVoiceInput} disabled={isProcessing} title="Dictate Response">ðŸŽ¤</button>
                                    <button className="action-btn send-btn" onClick={handleSend} disabled={isProcessing}>âž¤</button>
                                </div>
                            </div>
                        )
                    }
                    {
                        showSettings && (
                            <div className="settings-overlay">
                                <div className="settings-modal">
                                    <h2>Google AI Settings</h2>
                                    <p>This application requires a Google AI API key to function. Your key is stored locally in your browser and is never sent to our servers.</p>

                                    {/* SAVED KEYS LIST */}
                                    {apiKeys.length > 0 && (
                                        <div className="saved-keys-section" style={{ marginBottom: '15px', padding: '10px', background: '#f0f9ff', borderRadius: '6px', border: '1px solid #e0f2fe' }}>
                                            <h4 style={{ margin: '0 0 8px 0', fontSize: '0.9em', color: '#0369a1' }}>Active Keys (Vault)</h4>
                                            <div style={{ maxHeight: '100px', overflowY: 'auto' }}>
                                                {apiKeys.map((k, i) => (
                                                    <div key={i} style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.85em', padding: '4px 0', borderBottom: '1px solid #e0f2fe' }}>
                                                        <span><strong>{k.label}</strong>: {k.key.substring(0, 8)}...</span>
                                                        <span onClick={() => handleRemoveKey(i)} style={{ cursor: 'pointer', color: 'red', fontWeight: 'bold' }}>âœ•</span>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}

                                    <div className="api-input-group">
                                        <label>Google API Key</label>
                                        <input
                                            type="password"
                                            className="input-box"
                                            placeholder="Paste your key here..."
                                            value={tempKey}
                                            onChange={(e) => setTempKey(e.target.value)}
                                        />

                                        {/* Extra key inputs */}
                                        {extraKeys.map((key, idx) => (
                                            <input
                                                key={idx}
                                                type="password"
                                                className="input-box"
                                                style={{ marginTop: '8px' }}
                                                placeholder={`Paste key #${idx + 2} here...`}
                                                value={key}
                                                onChange={(e) => {
                                                    const updated = [...extraKeys];
                                                    updated[idx] = e.target.value;
                                                    setExtraKeys(updated);
                                                }}
                                            />
                                        ))}

                                        <div style={{ marginTop: '8px', textAlign: 'right' }}>
                                            <a
                                                href="#"
                                                onClick={(e) => { e.preventDefault(); setExtraKeys([...extraKeys, '']); }}
                                                style={{ fontSize: '0.85em', color: 'var(--primary)', textDecoration: 'none' }}
                                            >
                                                + Add one more key
                                            </a>
                                        </div>
                                    </div>

                                    <div className="instructions" style={{ marginBottom: '20px', paddingRight: '10px' }}>
                                        <p style={{ fontWeight: '600', marginBottom: '8px', color: 'var(--slate-800)' }}>How to get your API Key:</p>
                                        <ol style={{ paddingLeft: '20px', fontSize: '13px', color: 'var(--slate-600)' }}>
                                            <li style={{ marginBottom: '8px' }}>Go to <a href="https://aistudio.google.com/" target="_blank" style={{ color: 'var(--primary)' }}>Google AI Studio</a>.</li>
                                            <li style={{ marginBottom: '8px' }}>Click on "Projects", then on "+ Create a new project", name your project <strong>GEO309</strong>, and click "Create project".</li>
                                            <li style={{ marginBottom: '8px' }}>Click on "Get API key", then on "Create API key", name your key "GEO309", select the project you just created, and click "Create key".</li>
                                            <li style={{ marginBottom: '8px' }}>Copy the key.</li>
                                            <li style={{ marginBottom: '8px' }}>Paste that key here and click Save Key.</li>
                                        </ol>
                                        <p style={{ fontSize: '13px', color: 'var(--slate-600)', marginTop: '12px', fontStyle: 'italic' }}>
                                            You can add multiple keys from different email accounts to avoid quota limits! Simply repeat steps 1 to 5 using different emails.
                                        </p>
                                    </div>

                                    <div className="modal-actions">
                                        <button className="btn-secondary" onClick={() => setShowSettings(false)}>Cancel</button>
                                        <button className="btn-primary" onClick={handleAddKeys}>Save Key</button>
                                    </div>
                                </div>
                            </div>
                        )
                    }
                    <footer className="landing-footer">
                        IStudy is an AI-powered essay review developed by <a href="https://github.com/Camilo-Mora" target="_blank">Camilo Mora, Ph.D.</a>
                    </footer>
                </div >
            );
        }
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>

</html>