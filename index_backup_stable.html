<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iStudy - Student Essay Review System</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Outfit:wght@400;600;800&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <script src="https://unpkg.com/react-markdown@8.0.7/react-markdown.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { motion, AnimatePresence } = window.Motion || { motion: (p) => <div {...p} />, AnimatePresence: (p) => p.children };
        const ReactMarkdown = window.ReactMarkdown?.default || window.ReactMarkdown;

        // Core and Fetch Logic
        window.Core = window.Core || {
            UploadFile: async (file) => {
                console.log("Processing file:", file.name);
                return { fileId: "mock-" + Date.now(), fileName: file.name };
            },
            FetchChapterData: async (chapterNum) => {
                const paddedChapter = chapterNum.toString().padStart(2, '0');
                const questionsUrl = `https://raw.githack.com/Camilo-Mora/GEO309/main/main/ExamQuestions_${paddedChapter}.xlsx`;
                const transcriptUrl = `https://raw.githack.com/Camilo-Mora/GEO309/main/main/Transcript_Lecture_${paddedChapter}.txt`;

                try {
                    const qRes = await fetch(questionsUrl);
                    if (!qRes.ok) throw new Error(`Questions for Chapter ${paddedChapter} not found.`);
                    const qBuffer = await qRes.arrayBuffer();
                    const qData = new Uint8Array(qBuffer);
                    const workbook = XLSX.read(qData, { type: 'array' });
                    const worksheet = workbook.Sheets[workbook.SheetNames[0]];

                    const rawRows = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    const tRes = await fetch(transcriptUrl);
                    let transcript = "No transcript available.";
                    if (tRes.ok) {
                        transcript = await tRes.text();
                    }

                    return {
                        questions: rawRows
                            .filter(row => row && row.length >= 2 && row[1] && row[1].toString().trim().length > 0)
                            .map((row) => ({
                                question_number: row[0] || "N/A",
                                question_text: row[1].toString().trim(),
                                timestamp: row[2] ? row[2].toString().trim() : null
                            })),
                        transcript: transcript
                    };
                } catch (err) {
                    console.error("Fetch Error:", err);
                    throw err;
                }
            },
            ExtractDataFromUploadedFile: async (file) => {
                try {
                    let text = '';
                    if (file.type.startsWith('image/')) {
                        const worker = await Tesseract.createWorker('eng', 1);
                        const { data } = await worker.recognize(file);
                        text = data.text;
                        await worker.terminate();
                    } else {
                        text = await file.text();
                    }

                    const lines = text.split('\n').filter(l => l.trim().length > 5);

                    const chapterMatch = text.match(/(?:chapter|chap|unit|lecture)\s*[:.-]?\s*(\d+)/i);
                    return {
                        detected_chapter: chapterMatch ? chapterMatch[1] : null,
                        full_text: text,
                        transcribed_responses: lines
                    };
                } catch (err) {
                    console.error("Extraction Error:", err);
                    throw new Error("Failed to read content from file.");
                }
            },
            SmartParseResponses: async (rawText, expectedCount, chapterNum) => {
                const prompt = `
                    I have the following raw text extracted from a student's answer sheet for Chapter ${chapterNum}.
                    The chapter has ${expectedCount} questions total.
                    
                    Raw Text:
                    """${rawText}"""

                    Task:
                    1. Identify ALL individual answers present in the text.
                    2. Merge multi-line answers into single strings.
                    3. Ignore question text if repeated, headers, or footers.
                    4. Return ONLY the answers you actually find - do NOT make up or pad responses if some are missing.
                    5. Output STRICTLY a valid JSON array of strings (e.g., ["Ans 1", "Ans 2"]). Do NOT use Markdown code blocks.
                    
                    IMPORTANT: Return only the responses that are actually present in the text. If there are fewer responses than ${expectedCount}, that's okay - just return what you find.
                `;

                try {
                    // Read preference
                    const preferredModel = localStorage.getItem('iStudy_preferred_model') || 'gemini-3-flash';
                    const data = await window.Core.GeminiRequest(preferredModel, prompt);

                    let text = data.candidates[0].content.parts[0].text;
                    console.log("LLM Raw Response:", text);

                    const jsonMatch = text.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    } else {
                        throw new Error("No JSON array found in response");
                    }

                    const parsed = JSON.parse(text);
                    if (!Array.isArray(parsed)) throw new Error("Parsed result is not an array");

                    return { responses: parsed, error: null };
                } catch (err) {
                    console.error("Smart Parse Error:", err);
                    const msg = err.message || "";
                    if (msg.toLowerCase().includes("quota") || msg.toLowerCase().includes("limit") || msg.toLowerCase().includes("429")) {
                        return { responses: null, error: "âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**System Locked:** You cannot proceed without a valid API key. \n\n**To Unlock:** Generate a new API key using a **different personal Gmail account** and add it via the âš™ï¸ icon. Our app will loop over available keys. \n\nYou can also restart tomorrow as quotas are reset by Google at midnight Pacific time. \n\n*Note: UH emails DO NOT support API keys.*" };
                    }
                    return { responses: null, error: msg };
                }
            },
            GeminiRequest: async (model, promptText) => {
                let raw = localStorage.getItem('google_api_key');
                if (!raw) throw new Error("No API Key found.");

                let keys = [];
                try {
                    const parsed = JSON.parse(raw);
                    if (Array.isArray(parsed)) {
                        keys = parsed;
                    } else {
                        keys = [{ key: raw, label: 'Default' }];
                    }
                } catch (e) {
                    keys = [{ key: raw, label: 'Default' }];
                }

                keys = keys.filter(k => k && k.key && k.key.trim().length > 10);
                if (keys.length === 0) throw new Error("No valid API Keys available.");

                // Normalize model input or use default from localStorage if available in context, else hard default
                // Normalize model input or use default from localStorage if available in context, else hard default
                let targetModel = model || 'gemini-3-flash-preview';

                // Strict Chain: Only use the two verified working models
                // If user selected 2.5, try that first, then 3-preview.
                // If user selected 3 (or anything else), try 3-preview first, then 2.5.
                let uniqueChain = [];
                if (targetModel === 'gemini-2.5-flash') {
                    uniqueChain = ['gemini-2.5-flash', 'gemini-3-flash-preview'];
                } else {
                    uniqueChain = ['gemini-3-flash-preview', 'gemini-2.5-flash'];
                }

                const errorLog = [];

                // DEEP LOOP: Iterate through Models first, then Keys
                for (const currentModel of uniqueChain) {
                    console.log(`[Core] Attempting Model Phase: ${currentModel}`);

                    for (let i = 0; i < keys.length; i++) {
                        const kObj = keys[i];
                        const apiKey = kObj.key.trim();
                        const url = `https://generativelanguage.googleapis.com/v1beta/models/${currentModel}:generateContent?key=${apiKey}`;

                        try {
                            console.log(`AiCall [Key: ${kObj.label || 'Default'} | Model: ${currentModel}]: Requesting...`);
                            const response = await fetch(url, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] })
                            });

                            const data = await response.json();

                            if (data.error) {
                                const msg = data.error.message || JSON.stringify(data.error);
                                const errStr = `[${currentModel}]: ${msg}`;
                                console.warn(errStr);
                                errorLog.push(errStr);
                                continue; // Try next key/model
                            }

                            return data; // Success!

                        } catch (err) {
                            const msg = err.message || "Network/Fetch Error";
                            const errStr = `[${currentModel} Net]: ${msg}`;
                            console.warn(errStr);
                            errorLog.push(errStr);
                            continue;
                        }
                    }
                }

                // If we get here, all failed.
                const finalMsg = "Unable to generate response. All models failed:\n" + errorLog.join("\n");
                console.error(finalMsg);
                throw new Error(finalMsg);
            },

            BatchAnalyzeResponses: async (transcript, questions, studentResponses) => {
                const prompt = `
                    Analyze these student responses for a Biogeography course based on the lecture transcript.
                    
                    Transcript: "${transcript.substring(0, 15000)}" // Truncate for safety
                    
                    Questions & Student Responses:
                    ${questions.map((q, i) => `
                    Q${q.question_number}: ${q.question_text}
                    Student said: "${studentResponses[i]}"
                    `).join('\n')}

                    Task:
                    Review each response. Provide:
                    1. A grade (1-5).
                    2. A concise critique.
                    3. A model answer based on the transcript.
                    4. The exact timestamp (e.g. 12:45) from the lecture transcript where the answer is found.

                    Output MUST be a STRICT JSON array of objects:
                    [{"grade": 4, "critique": "...", "model_answer": "...", "timestamp": "12:45"}, ...]
                `;

                try {
                    // Use user preference for batch analysis too
                    const preferredModel = localStorage.getItem('iStudy_preferred_model') || 'gemini-3-flash';
                    const data = await window.Core.GeminiRequest(preferredModel, prompt);
                    let raw = data.candidates[0].content.parts[0].text;
                    console.log("Batch Analysis Raw Response:", raw);
                    const jsonMatch = raw.match(/\[[\s\S]*\]/);
                    if (jsonMatch) raw = jsonMatch[0];
                    const parsed = JSON.parse(raw);
                    if (!Array.isArray(parsed)) throw new Error("Batch analysis did not return an array.");

                    return parsed;
                } catch (e) {
                    console.error("Batch Analysis Error:", e);
                    const msg = e.message || String(e);
                    if (msg.toLowerCase().includes("quota") || msg.toLowerCase().includes("limit") || msg.includes("429")) {
                        throw e; // Propagate Quota errors to trigger Lock
                    }
                    return questions.map(() => ({ grade: 1, critique: "Analysis failed", model_answer: "N/A" }));
                }
            },
            VerifyStudentEmail: async (email) => {
                const scriptUrl = 'https://script.google.com/macros/s/AKfycbz5N8t6TKRA2AOI0q_jgavk9-Rv9JK4QEIDm0Nh41zAKhjVbWJeYZKbzXKDZxYyTq5N2w/exec';
                const url = `${scriptUrl}?action=send-code&email=${encodeURIComponent(email)}`;
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    return data;
                } catch (err) {
                    return { status: 'error', message: err.toString() };
                }
            },
            VerifyOTP: async (email, code) => {
                const scriptUrl = 'https://script.google.com/macros/s/AKfycbz5N8t6TKRA2AOI0q_jgavk9-Rv9JK4QEIDm0Nh41zAKhjVbWJeYZKbzXKDZxYyTq5N2w/exec';
                const url = `${scriptUrl}?action=verify-code&email=${encodeURIComponent(email)}&code=${encodeURIComponent(code)}`;
                try {
                    const response = await fetch(url);
                    const data = await response.json();
                    return data;
                } catch (err) {
                    return { status: 'error', message: err.toString() };
                }
            },
            RegisterCompletion: async (email, chapter) => {
                const scriptUrl = 'https://script.google.com/macros/s/AKfycbz5N8t6TKRA2AOI0q_jgavk9-Rv9JK4QEIDm0Nh41zAKhjVbWJeYZKbzXKDZxYyTq5N2w/exec';

                // Determine if it's a Video or a Chapter
                const isVideo = chapter.toString().toLowerCase().includes('video');
                const chNum = parseInt(chapter.toString().replace(/(chapter|video)/i, '').trim());
                const paddedNum = chNum.toString().padStart(2, '0');

                // Matches standard course naming: "Chapter 01" or "Video 06"
                // Matches standard course naming: "Chapter 01" or "Video 06"
                const chapterLabel = isVideo ? `Video ${paddedNum}` : `Chapter ${paddedNum}`;

                const payload = {
                    email: email,
                    studentId: email, // Universal key compatibility
                    chapter: chapterLabel
                };

                try {
                    console.log(`Registering completion:`, payload);
                    await fetch(scriptUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'text/plain' },
                        body: JSON.stringify(payload)
                    });
                    return { status: 'success' };
                } catch (err) {
                    console.error("Registration error:", err);
                    return { status: 'error', message: err.toString() };
                }
            }
        };

        window.InvokeLLM = async (prompt, context = {}) => {
            const systemContext = `
                You are playing a role in an educational system for a Biogeography course.
                Your task is to respond as an AI character to a student's response.
                
                Course Data:
                - Lecture Transcript: ${context.transcript || 'Not available'}
                - The Question: ${context.question || 'Not available'}
                - Student's Transcribed Response: ${context.student_response || 'Not available'}

                Character/Instruction: ${prompt}
                
                Please keep your response academic yet engaging, and stay strictly within the context of the course transcript provided.
            `;

            try {
                const data = await window.Core.GeminiRequest('gemini-2.5-flash', systemContext);
                return data.candidates[0].content.parts[0].text;
            } catch (err) {
                console.error("Gemini API Error:", err);
                const msg = err.message || "";
                if (msg.toLowerCase().includes("quota") || msg.toLowerCase().includes("limit") || msg.toLowerCase().includes("429")) {
                    return "System: âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**What to do:** \n1. Wait for it to reset (usually 15-60 minutes). \n2. OR, generate a new API key using a **different personal Gmail account** and update it via the âš™ï¸ icon. \n\n*Note: UH emails DO NOT support API keys.*";
                }
                return `System: Error calling Gemini AI. Check your API key or connection. Details: ${msg}`;
            }
        };

        const characters = {
            newton: { name: "Newton", emoji: "", avatarClass: "avatar-newton" },
            tontin: { name: "Tontin", emoji: "", avatarClass: "avatar-tontin" },
            joker: { name: "Joker", emoji: "", avatarClass: "avatar-joker" },
            system: { name: "System", emoji: "", avatarClass: "avatar-system" },
            user: { name: "Student", emoji: "ðŸ‘¤", avatarClass: "" }
        };

        function App() {
            const [showSettings, setShowSettings] = React.useState(false);
            const [apiKey, setApiKey] = React.useState(''); // Legacy check
            const [apiKeys, setApiKeys] = React.useState([]); // New: List of { key, label }
            const [newKeyLabel, setNewKeyLabel] = React.useState('');
            const [tempKey, setTempKey] = React.useState('');
            const [extraKeys, setExtraKeys] = React.useState([]); // For dynamic inputs
            const [email1, setEmail1] = useState('');
            const [email2, setEmail2] = useState('');
            const [isEditing, setIsEditing] = useState(false);
            const [isChoosingEditId, setIsChoosingEditId] = useState(false);
            const [isVerifyingEmail, setIsVerifyingEmail] = useState(false);
            const [isWaitingForOTP, setIsWaitingForOTP] = useState(false);
            const retryRequestRef = useRef(null); // For Auto-Retry Logic
            const [roadmapData, setRoadmapData] = useState(null);
            const [view, setView] = useState('landing');
            const [messages, setMessages] = useState([]);
            const [inputValue, setInputValue] = useState('');
            const [isProcessing, setIsProcessing] = useState(false);
            const [currentQIndex, setCurrentQIndex] = useState(0);
            const [reviewStep, setReviewStep] = useState(0);
            const [suggestedChapter, setSuggestedChapter] = useState(null);
            const [jokerData, setJokerData] = useState({ mode: '', statement: '' });
            const [hasIntroduced, setHasIntroduced] = useState({ newton: false, tontin: false, joker: false });
            const [isWaitingForReviewStart, setIsWaitingForReviewStart] = useState(false);
            const [isWaitingForAvatarStart, setIsWaitingForAvatarStart] = useState(false);
            const [isWaitingForNextQuestion, setIsWaitingForNextQuestion] = useState(false);
            const [isWaitingForCompilation, setIsWaitingForCompilation] = useState(false);
            const [isWaitingForIntroDisclaimer, setIsWaitingForIntroDisclaimer] = useState(false);
            const [isSystemLocked, setIsSystemLocked] = useState(false);
            const [lastUserInput, setLastUserInput] = useState('');

            // Internal InvokeLLM with Lock Logic
            const invokeLLM = async (prompt, context = {}) => {
                const systemContext = `
                    You are playing a role in an educational system for a Biogeography course.
                    Your task is to respond as an AI character to a student's response.
                    
                    Course Data:
                    - Lecture Transcript: ${context.transcript || 'Not available'}
                    - The Question: ${context.question || 'Not available'}
                    - Student's Transcribed Response: ${context.student_response || 'Not available'}

                    Character/Instruction: ${prompt}
                    
                    Please keep your response academic yet engaging, and stay strictly within the context of the course transcript provided.
                `;

                try {
                    const targetModel = selectedModel || 'gemini-3-flash-preview';
                    const data = await window.Core.GeminiRequest(targetModel, systemContext);
                    return data.candidates[0].content.parts[0].text;
                } catch (err) {
                    console.error("Gemini API Error:", err);
                    const msg = err.message || "";
                    if (msg.toLowerCase().includes("quota") || msg.toLowerCase().includes("limit") || msg.toLowerCase().includes("429")) {
                        setIsSystemLocked(true);
                        addMessage('system', "âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**System Locked:** You cannot proceed without a valid API key. \n\n**To Unlock:** Generate a new API key using a **different personal Gmail account** and add it via the âš™ï¸ icon. Our app will loop over available keys. \n\nYou can also restart tomorrow as quotas are reset by Google at midnight Pacific time. \n\n*Note: UH emails DO NOT support API keys.*");
                        retryRequestRef.current = { type: 'CHAT' };
                        return null; // Signal to Halt
                    }
                    addMessage('system', `System Error: ${msg}`);
                    return null;
                }
            };
            const [selectedModel, setSelectedModel] = useState(localStorage.getItem('iStudy_preferred_model') || 'gemini-3-flash');

            const [submission, setSubmission] = useState({
                student_email: '',
                chapter: '',
                questions: [],
                transcript: '',
                status: 'in_progress'
            });

            const chatScrollRef = useRef(null);
            const fileInputRef = useRef(null);
            const inputRef = useRef(null);

            // Auto-resize textarea
            useEffect(() => {
                if (inputRef.current) {
                    inputRef.current.style.height = 'auto';
                    inputRef.current.style.height = Math.min(inputRef.current.scrollHeight, 200) + 'px';
                }
            }, [inputValue]);

            useEffect(() => {
                if (chatScrollRef.current) {
                    chatScrollRef.current.scrollTo({ top: chatScrollRef.current.scrollHeight, behavior: 'smooth' });
                }
            }, [messages]);

            const addMessage = (charKey, text, type = 'text') => {
                setMessages(prev => [...prev, {
                    id: Math.random(),
                    charKey,
                    text: text,
                    type: type,
                    isAi: charKey !== 'user'
                }]);
            };

            const handleUploadClick = () => {
                if (apiKeys.length === 0) {
                    setShowSettings(true);
                    return;
                }

                if (submission.student_email && roadmapData) {
                    fileInputRef.current.click();
                } else {
                    setView('chat');
                    addMessage('system', "Before we get started, I need to confirm you are registered in this class. Please tell me the email address you used to register?");
                    setIsVerifyingEmail(true);
                }
            };

            const handleFileChange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                setView('chat');

                const allowedExtensions = ['.txt', '.md', '.png', '.jpg', '.jpeg'];
                const isImage = file.type.startsWith('image/');
                const hasValidExt = allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));

                if (!isImage && !hasValidExt) {
                    addMessage('system', "We only process .png, .txt, and .md files. If you did your essay in a different program like Word or Excel, simply open your file in that program, click on \"Save As\" and find the option for .txt. That will create the file in the format we need here.");
                    addMessage('system', null, 'reupload_action');
                    return;
                }

                setIsProcessing(true);

                if (!file.type.startsWith('image/')) {
                    addMessage('system', "ðŸ’¡ **Did you know?**\nResearch shows that handwriting responses significantly improves conceptual understanding and retention compared to typing. While I can process digital text, I highly encourage using handwritten notes for your own learning benefit.");
                }

                // addMessage('system', `Hello! File **${file.name}** received. I am processing your content now...`);

                try {
                    const extraction = await window.Core.ExtractDataFromUploadedFile(file);
                    // addMessage('system', "### Extracted Text:\n" + extraction.full_text);
                    window.lastTranscribed = extraction.transcribed_responses;
                    window.lastRawText = extraction.full_text;

                    if (extraction.detected_chapter) {
                        setSuggestedChapter(extraction.detected_chapter);
                        addMessage('system', `I detected **Chapter ${extraction.detected_chapter}**. Is this correct? (Yes/No)`);
                    } else {
                        addMessage('system', "I couldn't find a chapter number in your file. Which chapter is this for? (e.g., 1)");
                    }
                } catch (err) {
                    addMessage('system', "Error processing file: " + err.message);
                } finally {
                    setIsProcessing(false);
                }
            };

            const handleChapterSelected = async (chapterNum) => {
                setIsProcessing(true);
                addMessage('system', "I am processing your responses... this may take a moment");
                try {
                    const data = await window.Core.FetchChapterData(chapterNum);

                    const questionCount = data.questions.length;

                    // Attempt Smart Segmentation
                    const smartResult = await window.Core.SmartParseResponses(window.lastRawText || "", questionCount, chapterNum);

                    if (smartResult && smartResult.responses) {
                        window.lastTranscribed = smartResult.responses;
                    } else if (smartResult && smartResult.error) {
                        if (smartResult.error.toLowerCase().includes('quota') || smartResult.error.includes('429')) {
                            addMessage('system', "âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**System Locked:** You cannot proceed without a valid API key. \n\n**To Unlock:** Generate a new API key using a **different personal Gmail account** and add it via the âš™ï¸ icon. Our app will loop over available keys. \n\nYou can also restart tomorrow as quotas are reset by Google at midnight Pacific time. \n\n*Note: UH emails DO NOT support API keys.*");
                            setIsSystemLocked(true); // LOCK SYSTEM
                            retryRequestRef.current = { type: 'CHAPTER_SELECT', payload: { chapterNum } };
                            setIsProcessing(false);
                            return; // STOP HERE
                        }
                        addMessage('system', `Smart analysis warning: ${smartResult.error}. Falling back to line-by-line mode.`);
                    } else {
                        addMessage('system', "Smart analysis failed. Falling back to line-by-line mode.");
                    }

                    const responseCount = window.lastTranscribed ? window.lastTranscribed.length : 0;

                    console.log(`DEBUG: questionCount=${questionCount}, responseCount=${responseCount}`);

                    if (questionCount !== responseCount) {
                        addMessage('system', `âŒ **Mismatch Detected!** Chapter ${chapterNum} has ${questionCount} questions, but your response sheet has ${responseCount} responses. Please upload a completed response sheet. Ensure to clearly enumerate your responses.`);
                        addMessage('system', null, 'reupload_action');
                        setIsProcessing(false);
                        return;
                    }

                    // BATCH ANALYSIS START
                    runBatchAnalysis(data.transcript, data.questions, window.lastTranscribed, chapterNum);

                } catch (err) {
                    addMessage('system', "Error fetching chapter data: " + err.message);
                    setIsProcessing(false);
                }
            };

            const runBatchAnalysis = async (transcript, questions, responses, chapterNum) => {
                try {
                    const analysisResults = await window.Core.BatchAnalyzeResponses(transcript, questions, responses);

                    const enrichedQuestions = questions.map((q, i) => ({
                        ...q,
                        student_response: responses[i],
                        initial_response: responses[i],
                        final_response: responses[i],
                        analysis: analysisResults[i] || { grade: 0, critique: "Analysis failed", model_answer: "N/A" }
                    }));

                    setSubmission(prev => ({
                        ...prev,
                        chapter: chapterNum,
                        transcript: transcript,
                        questions: enrichedQuestions,
                        status: 'reviewing'
                    }));

                    const chaptersCompleted = roadmapData ? Object.keys(roadmapData).filter(k =>
                        (k.toLowerCase().includes('chapter') || k.toLowerCase().includes('video')) && roadmapData[k]
                    ).length : 0;

                    if (chaptersCompleted === 0) {
                        addMessage('system', "Here we will review your responses. This may take up to 60 minutes, ensure you have that time available until you finish, as partial work cannot be saved. \n\nOur purpose here is threefold: 1) ensure that you collected the correct information, 2) that you understand the information, and 3) that you can critically use it. For that you will interact with three different AI agents. Ready to meet them?");
                        setIsWaitingForIntroDisclaimer(true);
                    } else if (chaptersCompleted < 4) {
                        addMessage('system', "Remember you need at least 60 minutes to finish this work, and that you will be talking to three different AI agents. Ready to meet them?");
                        setIsWaitingForIntroDisclaimer(true);
                    } else {
                        addMessage('system', "Remember we need at least 60 minutes to finish reviewing your responses. Are you ready?");
                        setIsWaitingForReviewStart(true);
                    }

                    setCurrentQIndex(0);
                    setReviewStep(0);
                    setIsProcessing(false);
                    setIsSystemLocked(false);

                } catch (err) {
                    const msg = err.message || String(err);
                    if (msg.includes('429') || msg.toLowerCase().includes('quota')) {
                        addMessage('system', "âš ï¸ **Quota Limit Reached!** You have reached your Google API limit. \n\n**System Locked:** You cannot proceed without a valid API key. \n\n**To Unlock:** Generate a new API key using a **different personal Gmail account** and add it via the âš™ï¸ icon. Our app will loop over available keys. \n\nYou can also restart tomorrow as quotas are reset by Google at midnight Pacific time. \n\n*Note: UH emails DO NOT support API keys.*");
                        setIsSystemLocked(true);
                        retryRequestRef.current = { type: 'BATCH', payload: { transcript, questions, responses, chapterNum } };
                    } else {
                        addMessage('system', "Error during batch analysis: " + msg);
                    }
                    setIsProcessing(false);
                }
            };


            const startReview = async (qIdx, step) => {
                runNextStep(qIdx, step);
            };

            // We allow passing 'questionsOverride' because state updates might not be immediate in the initial call
            const runNextStep = async (qIdx, step, studentMsg = "", questionsOverride = null) => {
                const currentQuestions = questionsOverride || submission.questions;
                const q = currentQuestions[qIdx];
                if (!q) {
                    addMessage('system', "Great, we have reviewed all questions now. I have to compile them for you to read and approve. After approving, your responses will be saved to your machine and a message of completion will be sent to Dr. Mora. You will also be able to modify or edit specific responses. Can I compile the responses now?");
                    setIsWaitingForCompilation(true);
                    setIsProcessing(false);
                    return;
                }


                // Removed the greedy update that was overwriting final_response with conversational 'Yes/No' messages.
                // Newton's phase (Step 0) now explicitly handles the final_response lock-in.

                // NEW: Skip introductions if any chapter/video is already completed
                const chaptersCompleted = roadmapData ? Object.keys(roadmapData).filter(k =>
                    (k.toLowerCase().includes('chapter') || k.toLowerCase().includes('video')) && roadmapData[k]
                ).length : 0;
                const skipIntro = chaptersCompleted >= 4;

                // LIGHTWEIGHT CONTEXT - Uses Pre-calc Model Answer instead of full Transcript
                const analysis = q.analysis || {};
                const commonContext = {
                    transcript: "Model Answer for context: " + analysis.model_answer, // Light context
                    question: q.question_text,
                    student_response: studentMsg || q.final_response || q.student_response
                };

                // STEP 0: NEWTON (Grades & Feedback) -> TONTIN INTRO
                // STEP 0: NEWTON (Structured Report & Discussion)
                if (step === 0) {
                    if (!studentMsg) {
                        setIsProcessing(true);
                        const report = `
### Question ${q.question_number}
#### Question:
${q.question_text}

#### Your Response:
${q.student_response}

#### Score:
${analysis.grade}/5

#### Feedback:
${analysis.critique}

#### Model Answer(AI):
${analysis.model_answer}

${analysis.timestamp ? `***I found this response around minute ${analysis.timestamp} of the video.***` : ''}
                        `;
                        addMessage('newton', report);
                        setTimeout(() => {
                            addMessage('newton', "Do you agree with this assessment? (Type **'Yes'** to accept the Model Answer, or provide a better explanation/argument to improve your score.)");
                            setIsProcessing(false);
                        }, 1000);
                        return;
                    } else {
                        setIsProcessing(true);
                        const lowerMsg = studentMsg.toLowerCase();
                        if (lowerMsg === 'yes' || lowerMsg === 'agree' || lowerMsg === 'ok' || lowerMsg.includes('accept')) {
                            setSubmission(prev => {
                                const newQs = [...prev.questions];
                                newQs[qIdx] = { ...newQs[qIdx], final_response: analysis.model_answer, final_grade: analysis.grade };
                                return { ...prev, questions: newQs };
                            });
                            setReviewStep(1);
                            setTimeout(() => runNextStep(qIdx, 1, ""), 500);
                        } else {
                            setIsProcessing(true);
                            const reEvalPrompt = `
                                You are Newton ðŸ§ . Analyze this student's improved explanation against the Model Answer.
                                
                                Model Answer: "${analysis.model_answer}"
                                Student's New Explanation: "${studentMsg}"
                                
                                Provide STRICTLY a JSON object with:
                        - "critique": String(feedback on the new explanation).
                                - "updated_model_answer": String(The original Model Answer, but updated to seamlessly incorporate any valid new details from the student's explanation. If the student's point is invalid, keep it unchanged).
                                
                                No markdown, just JSON.
                            `;

                            try {
                                const resText = await invokeLLM(reEvalPrompt, commonContext);
                                if (!resText) return; // HALT if Locked

                                const jsonMatch = resText.match(/\{[\s\S]*\}/);

                                const newEval = jsonMatch ? JSON.parse(jsonMatch[0]) : { critique: "I've reviewed your update.", updated_model_answer: analysis.model_answer };

                                // Ensure we have a valid model answer fallback
                                const finalModelAnswer = newEval.updated_model_answer || analysis.model_answer;

                                setSubmission(prev => {
                                    const newQs = [...prev.questions];
                                    newQs[qIdx] = {
                                        ...newQs[qIdx],
                                        analysis: { ...newQs[qIdx].analysis, ...newEval, model_answer: finalModelAnswer },
                                        student_response: studentMsg
                                    };
                                    return { ...prev, questions: newQs };
                                });

                                const report = `
### Question ${q.question_number}
#### Question:
${q.question_text}

#### Your Additional Comment:
${studentMsg}

#### Feedback:
${newEval.critique}

#### Model Answer (AI):
${finalModelAnswer}

${analysis.timestamp ? `***I found this response around minute ${analysis.timestamp} of the video.***` : ''}
`;
                                addMessage('newton', report);
                                setTimeout(() => {
                                    addMessage('newton', "Do you agree with this assessment? (Type **'Yes'** to accept this Updated Model Answer, or provide further explanation.)");
                                    setIsProcessing(false);
                                }, 1000);
                            } catch (err) {
                                console.error("Re-eval error:", err);
                                addMessage('newton', "I had trouble analyzing that. Could you try again or just say 'Yes' if you want to proceed?");
                                setIsProcessing(false);
                            }
                        }
                        setIsProcessing(false);

                    }
                }

                // STEP 1: TONTIN (One-Shot Feedback)
                else if (step === 1) {
                    if (!studentMsg) {
                        setIsProcessing(true);

                        await new Promise(r => setTimeout(r, 600));
                        addMessage('tontin', `Iâ€™m still a bit lost on this oneâ€”could you explain it to me in a different way? How would you explain this to a grandma? \n\n**The Question:** ${q.question_text}`);
                        setIsProcessing(false);
                        return;
                    } else {
                        setIsProcessing(true);
                        const tontinEvalPrompt = `### ROLE
You are "Tontin," a friendly, humble peer student. You are not a professor. You rely on the User to explain the lecture content correctly.

### INPUT DATA
1. **Student Explanation:** "${studentMsg}"
2. **Key Concepts:** "${analysis.model_answer}"

### TASK
Compare the **Student Explanation** against the **Key Concepts**. Identify what was explained well and what I (Tontin) am still confused about.

### CRITICAL RULE
**DO NOT ASK ANY QUESTIONS.** Do not use phrases like "Does that make sense?" or "Can you clarify?". The student cannot respond to this message. Simply state your assessment.

### OUTPUT FORMAT
You must follow this EXACT structure. Use Headers (###) for sections. Do not use standard bullet points (* or -), just use the emojis. CRITICAL: Separate each point with a full blank line.

### Greeting
A single, warm sentence acknowledging the student's help (e.g., "Thanks for explaining that!"). Do not ask how I am or if I understood.

### What was clear: 

âœ… [First concept you understood clearly]

âœ… [Second concept if applicable]

### What is confusing: 

â“ [First concept that remains missing or vague in their explanation]

â“ [Second concept if applicable]

**My assessment:** [Low, Medium, or High]. 

* If **High**: "This is great, it is clear to me now."
* If **Medium or Low**: "I am still not fully clear about this response; I will watch that part of the video again to be certain."

### TONE RULES
* **No Questions:** Under no circumstances should you ask a question. The student cannot reply.
* **Be specific:** State exactly what concept you are referring to in each point.
* **Be humble:** Always frame missing info as something you missed or didn't understand. 
* **Formatting:** ENSURE A BLANK LINE between every point. Also ensure a blank line before "**My assessment:**".
`;

                        const tontinEval = await invokeLLM(tontinEvalPrompt, commonContext);
                        if (!tontinEval) return; // HALT if Locked

                        addMessage('tontin', tontinEval);

                        // Transition to Joker
                        setIsProcessing(false);
                        setTimeout(() => {
                            setReviewStep(2);
                            addMessage('joker', "My turn! Can I go next?");
                            setIsWaitingForAvatarStart(true);
                        }, 1500);
                    }
                }

                // STEP 2: JOKER (Intro & Eval)
                else if (step === 2) {
                    if (!studentMsg) {
                        setIsProcessing(true);

                        // Randomly choose mode (50/50 chance)
                        const mode = Math.random() < 0.5 ? "TRUTHFUL" : "DECEPTIVE";

                        const jokerIntroPrompt = `### ROLE
You are "Joker," a confident but occasionally careless peer student. You are discussing a video lecture with another student. Your goal is to test the student's critical thinking by trying or not to deceive them.

### INPUT DATA
**The Question:** ${q.question_text}
**Actual Response (From Video):** ${analysis.model_answer}
**Mode:** ${mode}

### INSTRUCTIONS
In all cases, you must speak with high confidence, as if stating an absolute fact. 
Start with phrases like "I watched the lecture and I understand that..." or "Based on the lecture, I can say that...". 
Finish with a brief binary question for the student to confirm or deny your statement (e.g., "Do you concur?", "I am correct, right?", or "Do you agree?"). Phrase the question expecting a binary response (Yes/No).

**If Mode is "TRUTHFUL":**
* Paraphrase the **Actual Response** using slightly different vocabulary to show understanding.
* Keep it brief and encouraging.

**If Mode is "DECEPTIVE":**
* You must generate a statement that sounds plausible but contains a **clear, objective error**.
* **CRITICAL CONSTRAINT:** Do not use vague semantic tricks. Do not split hairs on definitions. The error must be factual or logical.
* **Use one of these 3 Deception Tactics:**
    1.  **The Reversal:** Swap the Cause and Effect (e.g., "The rain causes the clouds" instead of "Clouds cause rain").
    2.  **The Absolute:** Remove a necessary condition (e.g., "Water always boils at 100Â°C" -> omit "at sea level").
    3.  **The Myth:** Confidently state a common misconception related to the topic.

### SAFETY CHECK (Self-Correction)
Before outputting a DECEPTIVE response, ask yourself: "Is this error obvious enough that a professor would mark it wrong?" If the answer is "It's debatable," **discard it** and choose a more obvious error.

### OUTPUT FORMAT
Output *only* your dialogue as Joker. Do not include labels like "Statement:" or "Mode:".`;

                        const jokerRes = await invokeLLM(jokerIntroPrompt, commonContext);
                        if (!jokerRes) return; // HALT if Locked
                        setJokerData({ mode, statement: jokerRes });
                        addMessage('joker', jokerRes);
                        setIsProcessing(false);
                        return;
                    } else {
                        setIsProcessing(true);
                        const jokerEvalPrompt = `### ROLE
You are Joker ðŸƒ, a peer student who just made a statement to another student. You were in ${jokerData.mode} mode.

### CONTEXT
**The Actual Answer (Fact):** ${analysis.model_answer}
**Your Previous Statement:** "${jokerData.statement}"
**Target Mode during statement:** ${jokerData.mode}
**Student's Reaction:** "${studentMsg}"

### TASK
1. Determine if the student correctly identified your statement as TRUTHFUL or DECEPTIVE.
2. Provide feedback.

### FEEDBACK RULES
* Use a friendly, peer-student tone.
* If you were in **DECEPTIVE** mode:
    * If the student caught your trick: "Nice catch! I was actually trying to trick you with a factual error, but you didn't fall for it. You correctly identified that [explain the error briefly]."
    * If the student missed the trick: "Haha! I actually tricked you! I was being deceptiveâ€”the part about [X] was wrong. The video actually said [Y]."
* If you were in **TRUTHFUL** mode:
    * If the student agreed: "Exactly! I was actually not trying to trick you there. You correctly recognized that I was being truthful about the lecture content."
    * If the student disagreed (thought it was a trick): "Oh, actually I wasn't trying to trick you that time! I was being truthful, but you thought I was being deceptive. It turns out my statement was accurate according to the lecture."

### OUTPUT FORMAT
Output only your peer-style feedback                    `;

                        const jokerResponse = await invokeLLM(jokerEvalPrompt, commonContext);
                        if (!jokerResponse) return; // HALT if Locked

                        addMessage('joker', jokerResponse);
                        setIsProcessing(false);

                        // Move to next question after Joker feedback
                        setTimeout(() => {
                            if (qIdx < submission.questions.length - 1) {
                                addMessage('system', "Can we move to the next question?");
                                setIsWaitingForNextQuestion(true);
                            } else {
                                // Automatically trigger the "all reviewed" message from runNextStep
                                runNextStep(qIdx + 1, 0);
                            }
                        }, 1000);
                    }
                }
            };

            const runAvatarIntroductions = async () => {
                setIsProcessing(true);
                const chaptersCompleted = roadmapData ? Object.keys(roadmapData).filter(k =>
                    (k.toLowerCase().includes('chapter') || k.toLowerCase().includes('video')) && roadmapData[k]
                ).length : 0;

                if (chaptersCompleted === 0) {
                    // Full Ceremony
                    addMessage('newton', "I am Newton. My job is to measure the accuracy of your logic against the lecture material. Iâ€™ll provide a score and feedback to help you calibrate your understanding. Don't worryâ€”this isn't a grade; itâ€™s a diagnostic tool to help you sharpen your focus for future videos.");
                    await new Promise(r => setTimeout(r, 2000));
                    addMessage('tontin', "My name is Tontin. I will always ask you to explain the material in your own words. My role is to ensure you have a confident grasp of the course content and can express complex ideas clearly and independently.");
                    await new Promise(r => setTimeout(r, 2000));
                    addMessage('joker', "My name is Joker. I may or may not attempt to deceive you with my statements. My role is to help you become a critical thinker by challenging you to distinguish between accurate, partially correct, and completely false information.");
                } else {
                    // Team Huddle
                    addMessage('newton', "Newton here. Ready to verify your responses.");
                    addMessage('tontin', "Hi, this is Tontin, and I may still need you to explain things to me.");
                    addMessage('joker', "This is Joker here... watch out, as I may pull some tricks on you.");
                }

                await new Promise(r => setTimeout(r, 2000));
                addMessage('system', "**Let's review your responses one by one. Are you ready?**");
                setIsWaitingForReviewStart(true);
                setIsProcessing(false);
            };

            const handleVoiceInput = () => {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

                if (!SpeechRecognition) {
                    alert("Voice dictation is not fully supported in this browser.\n\nPlease use Google Chrome, Edge, or Safari for the best experience.");
                    return;
                }

                const recognition = new SpeechRecognition();
                recognition.lang = 'en-US';
                recognition.continuous = false;
                recognition.interimResults = false;

                recognition.onstart = () => {
                    addMessage('system', "ðŸŽ¤ Listening...");
                };

                recognition.onresult = (event) => {
                    const text = event.results[0][0].transcript;
                    setInputValue(prev => (prev ? prev + " " : "") + text);
                    // Remove system "Listening..." message if possible (optional refinement)
                };

                recognition.onerror = (event) => {
                    console.error("Voice recognition error", event.error);
                    if (event.error === 'not-allowed') {
                        alert("Microphone access blocked. Please check your browser settings.");
                    }
                };

                recognition.start();
            };

            const handleSend = async () => {
                if (!inputValue.trim() || isProcessing) return;
                const text = inputValue.trim();
                setInputValue('');
                addMessage('user', text);

                if (isVerifyingEmail) {
                    setIsProcessing(true);
                    const res = await window.Core.VerifyStudentEmail(text);
                    setIsProcessing(false);
                    if (res.status === 'success') {
                        setEmail1(text);
                        setEmail2(text);
                        setSubmission(prev => ({ ...prev, student_email: text }));
                        setIsVerifyingEmail(false);
                        setIsWaitingForOTP(true);
                        addMessage('system', "I just sent a 3-digit verification code to your email. Please enter that code below to unlock your session. \n\n*If the message is not in your Inbox, check your **Spam** or **Promotions** folder.*");
                    } else {
                        addMessage('system', "âŒ Your email was not found in the roster of this class. Please verify if this is the email you used to register or if you misspelled it, and try typing your email again. If that does not work, reach out to the Registrar's Office, as you do not appear to be registered in this class. If you are, please contact Dr. Mora.");
                    }
                    return;
                }

                if (isWaitingForOTP) {
                    setIsProcessing(true);
                    const res = await window.Core.VerifyOTP(submission.student_email, text);
                    setIsProcessing(false);
                    if (res.status === 'success') {
                        setIsWaitingForOTP(false);
                        setRoadmapData(res.completion);
                        addMessage('system', "Verification successful! Welcome back. Generating your progress roadmap...");
                        setTimeout(() => {
                            addMessage('system', '', 'roadmap');
                        }, 1000);
                    } else {
                        addMessage('system', "âŒ **Invalid Code.** The verification code you entered is incorrect. Please check your email and try again.");
                    }
                    return;
                }

                if (isChoosingEditId) {
                    setIsChoosingEditId(false);
                    const id = text.trim();
                    const idx = submission.questions.findIndex(q => q.question_number.toString() === id);
                    if (idx !== -1) {
                        setIsEditing(true);
                        setCurrentQIndex(idx);
                        setReviewStep(0);
                        const qToEdit = submission.questions[idx];
                        addMessage('newton', `### Editing Question ${id}\n**Question:** ${qToEdit.question_text}\n\n**Current Agreed Response:** ${qToEdit.final_response}\n\n*Please enter your improved response below:*`);
                    } else {
                        addMessage('system', `âŒ Question **${id}** not found. Please click "Edit a Response" again if you wish to try a different number.`);
                    }
                    return;
                }

                if (isWaitingForIntroDisclaimer) {
                    setIsWaitingForIntroDisclaimer(false);
                    runAvatarIntroductions();
                    return;
                }

                if (isWaitingForReviewStart) {
                    setIsWaitingForReviewStart(false);
                    runNextStep(0, 0, "");
                    return;
                }

                if (isWaitingForAvatarStart) {
                    setIsWaitingForAvatarStart(false);
                    // Just call runNextStep with current state to pick up where it left off
                    runNextStep(currentQIndex, reviewStep, "");
                    return;
                }

                if (isWaitingForCompilation) {
                    setIsWaitingForCompilation(false);
                    addMessage('system', 'Generating your report...', 'report');
                    return;
                }

                if (isWaitingForNextQuestion) {
                    setIsWaitingForNextQuestion(false);
                    setCurrentQIndex(currentQIndex + 1);
                    setReviewStep(0);
                    runNextStep(currentQIndex + 1, 0);
                    return;
                }

                if (isEditing && (text.toLowerCase().includes('yes') || text.toLowerCase().includes('report') || text.toLowerCase().includes('ok'))) {
                    // FIX: Commit the agreed model_answer to final_response before generating report
                    setSubmission(prev => {
                        const newQs = [...prev.questions];
                        const q = newQs[currentQIndex];
                        if (q && q.analysis && q.analysis.model_answer) {
                            newQs[currentQIndex] = { ...q, final_response: q.analysis.model_answer };
                        }
                        return { ...prev, questions: newQs };
                    });

                    setIsEditing(false);
                    addMessage('system', 'Generating your report...', 'report');
                    return;
                }

                if (!submission.chapter) {
                    if (suggestedChapter && ['yes', 'y', 'correct', 'sure', 'ok'].includes(text.toLowerCase())) {
                        setSuggestedChapter(null);
                        handleChapterSelected(suggestedChapter);
                        return;
                    }

                    const numMatch = text.match(/\d+/);
                    if (numMatch) {
                        setSuggestedChapter(null);
                        handleChapterSelected(numMatch[0]);
                    } else {
                        addMessage('system', "I didn't catch a valid chapter number. Please enter digits only (e.g., '1').");
                    }
                    return;
                }

                if (text.toLowerCase() === 'compile' || text.toLowerCase() === 'report') {
                    addMessage('system', 'Generating your report...', 'report');
                    return;
                }

                setLastUserInput(text); // Save for retry
                runNextStep(currentQIndex, reviewStep, text);
            };

            const generateReportData = () => {
                const content = `ISTUDY REPORT - CHAPTER ${submission.chapter} \n` +
                    `STUDENT ID: ${email1} \n` +
                    `------------------------------------------\n\n` +
                    submission.questions.map(q => `QUESTION ${q.question_number}: ${q.question_text} \nRESPONSE: ${q.final_response} \n`).join('\n---\n');
                const chNum = (submission.chapter || '0').toString().padStart(2, '0');
                const fileName = `Report_Chapter_${chNum}.txt`;
                return {
                    uri: 'data:text/plain;charset=utf-8,' + encodeURIComponent("\ufeff" + content),
                    fileName
                };
            };

            const saveKeysToStorage = (keys) => {
                localStorage.setItem('google_api_key', JSON.stringify(keys));
                setApiKeys(keys);
                if (keys.length > 0) setApiKey(keys[0].key); // Legacy compatibility
                else setApiKey('');
            };

            const handleAddKeys = () => {
                const inputs = [tempKey, ...extraKeys].filter(k => k && k.trim().length > 10);
                if (inputs.length === 0) {
                    setShowSettings(false);
                    return;
                }

                const newEntries = inputs.map((k, i) => ({
                    key: k.trim(),
                    label: `Account ${apiKeys.length + i + 1}`
                }));

                const newParams = [...apiKeys, ...newEntries];
                saveKeysToStorage(newParams);

                setTempKey('');
                setExtraKeys([]);
                setShowSettings(false);
                addMessage('system', `âœ… ${newEntries.length} key(s) added to vault.`);

                // AUTO-RETRY if Locked
                if (isSystemLocked && retryRequestRef.current) {
                    addMessage('system', "ðŸ”„ New key detected. Retrying previous step...");
                    setIsSystemLocked(false); // Optimistic Unlock

                    if (retryRequestRef.current.type === 'BATCH') {
                        const { transcript, questions, responses, chapterNum } = retryRequestRef.current.payload;
                        runBatchAnalysis(transcript, questions, responses, chapterNum);
                    } else if (retryRequestRef.current.type === 'CHAPTER_SELECT') {
                        const { chapterNum } = retryRequestRef.current.payload;
                        handleChapterSelected(chapterNum);
                    } else {
                        // Default to CHAT
                        runNextStep(currentQIndex, reviewStep, lastUserInput);
                    }
                }
            };

            const handleRemoveKey = (index) => {
                const newParams = apiKeys.filter((_, i) => i !== index);
                saveKeysToStorage(newParams);
            };

            // Load saved key on mount
            React.useEffect(() => {
                const raw = localStorage.getItem('google_api_key');
                if (raw) {
                    try {
                        const parsed = JSON.parse(raw);
                        if (Array.isArray(parsed)) {
                            setApiKeys(parsed);
                            if (parsed.length > 0) setApiKey(parsed[0].key);
                        } else {
                            // Legacy String
                            setApiKeys([{ key: raw, label: 'Default' }]);
                            setApiKey(raw);
                        }
                    } catch {
                        setApiKeys([{ key: raw, label: 'Default' }]);
                        setApiKey(raw);
                    }
                }
            }, []);

            // Auto-scroll to bottom when new messages arrive
            const messagesEndRef = React.useRef(null);

            React.useEffect(() => {
                if (messagesEndRef.current) {
                    messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages]);

            return (
                <div className="app-root">
                    <header>
                        <div className="logo">IStudy</div>
                        <div className="settings-icon" onClick={() => setShowSettings(true)}>
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                            </svg>
                        </div>
                    </header>
                    <main className="container">
                        <AnimatePresence mode="wait">
                            {view === 'landing' && (
                                <motion.div
                                    key="landing"
                                    initial={{ opacity: 0, y: 20 }}
                                    animate={{ opacity: 1, y: 0 }}
                                    exit={{ opacity: 0, scale: 0.95 }}
                                    className="landing-content"
                                >
                                    <video className="title-image" autoPlay loop muted playsInline>
                                        <source src="istudy-landing-video.mp4" type="video/mp4" />
                                    </video>

                                    <button className="main-upload-btn" onClick={handleUploadClick}>
                                        <span className="btn-icon">
                                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                                                <circle cx="12" cy="13" r="4"></circle>
                                            </svg>
                                        </span> Upload Response Sheet
                                    </button>




                                </motion.div>
                            )}
                            {view === 'chat' && (
                                <motion.div
                                    key="chat"
                                    initial={{ opacity: 0 }}
                                    animate={{ opacity: 1 }}
                                    className="chat-container active"
                                    ref={chatScrollRef}
                                >
                                    <video className="title-image image-shrunken" autoPlay loop muted playsInline>
                                        <source src="istudy-landing-video.mp4" type="video/mp4" />
                                    </video>
                                    <div className="messages-list">
                                        <AnimatePresence initial={false}>
                                            {messages.map((msg) => (
                                                <motion.div
                                                    key={msg.id}
                                                    initial={{ opacity: 0, y: 10, scale: 0.95 }}
                                                    animate={{ opacity: 1, y: 0, scale: 1 }}
                                                    className={`message-wrapper ${msg.isAi ? 'message-ai' : 'message-user'}`}
                                                >
                                                    <div className={`avatar ${characters[msg.charKey]?.avatarClass || ''}`}>
                                                        {!characters[msg.charKey]?.avatarClass ? (characters[msg.charKey]?.emoji || 'ðŸ‘¤') : null}
                                                    </div>
                                                    <div className="message-bubble">
                                                        {msg.type === 'report' ? (
                                                            <div className="report-chat-card">
                                                                <h3>Final Study Report - Chapter {submission.chapter}</h3>
                                                                <div className="report-list-mini">
                                                                    {submission.questions.map((q, qIdx) => (
                                                                        <div key={qIdx} className="report-item-mini">
                                                                            <p><strong>Q{q.question_number}:</strong> {q.question_text}</p>
                                                                            <p className="response-preview"><em>Response:</em> {q.final_response}</p>
                                                                        </div>
                                                                    ))}
                                                                </div>

                                                                <div className="report-actions-mini">
                                                                    <div style={{ marginBottom: '15px', color: 'var(--slate-500)', fontSize: '13px' }}>
                                                                        Verified as: <strong>{submission.student_email}</strong>
                                                                    </div>
                                                                    <button className="btn-secondary" style={{ width: '100%', marginBottom: '10px' }} onClick={() => {
                                                                        setIsChoosingEditId(true);
                                                                        addMessage('system', "Which question number would you like to edit? (Enter the digit, e.g., 1)");
                                                                    }}>Edit a Response</button>

                                                                    {(() => {
                                                                        const r = generateReportData();
                                                                        const canSubmit = !!submission.student_email;
                                                                        return (
                                                                            <a
                                                                                href={canSubmit ? r.uri : "javascript:void(0)"}
                                                                                download={canSubmit ? r.fileName : undefined}
                                                                                className={`btn - primary ${!canSubmit ? 'disabled' : ''} `}
                                                                                style={{
                                                                                    textDecoration: 'none',
                                                                                    textAlign: 'center',
                                                                                    display: 'block',
                                                                                    width: '100%',
                                                                                    boxSizing: 'border-box',
                                                                                    opacity: canSubmit ? 1 : 0.5,
                                                                                    cursor: canSubmit ? 'pointer' : 'not-allowed',
                                                                                    pointerEvents: canSubmit ? 'auto' : 'none'
                                                                                }}
                                                                                onClick={async (e) => {
                                                                                    if (!canSubmit) {
                                                                                        e.preventDefault();
                                                                                        return;
                                                                                    }
                                                                                    setIsProcessing(true);
                                                                                    try {
                                                                                        await window.Core.RegisterCompletion(
                                                                                            submission.student_email,
                                                                                            parseInt(submission.chapter, 10)
                                                                                        );
                                                                                        setTimeout(() => setView('completion'), 1500);
                                                                                    } catch (err) {
                                                                                        setView('completion');
                                                                                    } finally {
                                                                                        setIsProcessing(false);
                                                                                    }
                                                                                }}
                                                                            >
                                                                                Approve & Submit
                                                                            </a>
                                                                        );
                                                                    })()}
                                                                </div>
                                                            </div>
                                                        ) : msg.type === 'roadmap' ? (
                                                            <div className="roadmap-container">
                                                                <div className="roadmap-title">Academic Roadmap</div>

                                                                <div className="roadmap-section">
                                                                    <div className="roadmap-section-title">Chapters submitted</div>
                                                                    <div className="roadmap-row">
                                                                        {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13].map(num => {
                                                                            const padded = num.toString().padStart(2, '0');
                                                                            const isDone = roadmapData && (
                                                                                roadmapData[`chapter ${padded}`] ||
                                                                                roadmapData[`chapter${padded}`] ||
                                                                                roadmapData[`Chapter ${padded}`] ||
                                                                                roadmapData[`Chapter${padded}`] ||
                                                                                roadmapData[`chapter ${num}`] ||
                                                                                roadmapData[`chapter${num}`]
                                                                            );
                                                                            const grades = {
                                                                                1: 'F', 2: 'F', 3: 'F', 4: 'F', 5: 'D-', 6: 'D',
                                                                                7: 'D+', 8: 'C-', 9: 'C', 10: 'C+', 11: 'B-', 12: 'B', 13: 'B+'
                                                                            };
                                                                            return (
                                                                                <div key={num} className="roadmap-column">
                                                                                    <div className={`roadmap-box ${isDone ? 'completed' : ''}`}>
                                                                                        {num}
                                                                                        {isDone && <span className="tick">âœ“</span>}
                                                                                    </div>
                                                                                    <div className={`roadmap-grade-box ${isDone ? 'completed' : ''}`}>
                                                                                        {grades[num]}
                                                                                    </div>
                                                                                </div>
                                                                            );
                                                                        })}
                                                                    </div>
                                                                </div>

                                                                <div className="roadmap-section">
                                                                    <div className="roadmap-section-title">Video exam</div>
                                                                    <div className="roadmap-row">
                                                                        {[6, 8, 10].map(num => {
                                                                            const padded = num.toString().padStart(2, '0');
                                                                            const isDone = roadmapData && (
                                                                                roadmapData[`video ${padded}`] ||
                                                                                roadmapData[`video${padded}`] ||
                                                                                roadmapData[`Video ${padded}`] ||
                                                                                roadmapData[`Video${padded}`] ||
                                                                                roadmapData[`video ${num}`] ||
                                                                                roadmapData[`video${num}`]
                                                                            );
                                                                            const vGrades = { 6: 'A-', 8: 'A', 10: 'A+' };
                                                                            return (
                                                                                <div key={num} className="roadmap-column">
                                                                                    <div className={`roadmap-box ${isDone ? 'completed' : ''}`}>
                                                                                        {num}
                                                                                        {isDone && <span className="tick">âœ“</span>}
                                                                                    </div>
                                                                                    <div className={`roadmap-grade-box ${isDone ? 'completed' : ''}`}>
                                                                                        {vGrades[num]}
                                                                                    </div>
                                                                                </div>
                                                                            );
                                                                        })}
                                                                    </div>
                                                                </div>

                                                                <div style={{ marginTop: '20px' }}>
                                                                    <button
                                                                        className="main-upload-btn"
                                                                        style={{ fontSize: '16px', padding: '12px 24px', width: 'auto' }}
                                                                        onClick={() => fileInputRef.current.click()}
                                                                    >
                                                                        <span className="btn-icon">ðŸ“‚</span> Upload Response Sheet
                                                                    </button>
                                                                </div>
                                                            </div>
                                                        ) : msg.type === 'upload_action' ? (
                                                            <div className="action-card" style={{ textAlign: 'center', padding: '10px 0' }}>
                                                                <button
                                                                    className="main-upload-btn"
                                                                    style={{ fontSize: '16px', padding: '12px 24px', margin: '0 auto', width: 'auto' }}
                                                                    onClick={() => fileInputRef.current.click()}
                                                                >
                                                                    <span className="btn-icon">ðŸ“‚</span> Upload Response Sheet
                                                                </button>
                                                            </div>
                                                        ) : msg.type === 'reupload_action' ? (
                                                            <div className="action-card" style={{ textAlign: 'center', padding: '10px 0' }}>
                                                                <p style={{ marginBottom: '15px' }}>Please update your file and try again.</p>
                                                                <button
                                                                    className="main-upload-btn"
                                                                    style={{ fontSize: '16px', padding: '12px 24px', margin: '0 auto', width: 'auto' }}
                                                                    onClick={() => fileInputRef.current.click()}
                                                                >
                                                                    <span className="btn-icon">ðŸ“‚</span> Upload Corrected Sheet
                                                                </button>
                                                            </div>
                                                        ) : (
                                                            <div className="markdown-content">
                                                                <ReactMarkdown>{msg.text}</ReactMarkdown>
                                                            </div>
                                                        )}
                                                    </div>
                                                </motion.div>
                                            ))}
                                        </AnimatePresence>
                                        {isProcessing && (
                                            <div className="message-wrapper message-ai">
                                                <div className="avatar avatar-system"></div>
                                                <div className="message-bubble">
                                                    <div className="loading-spinner"></div>
                                                </div>
                                            </div>
                                        )}
                                        <div ref={messagesEndRef} />
                                    </div>
                                </motion.div>
                            )}
                            {view === 'completion' && (
                                <motion.div
                                    key="completion"
                                    initial={{ opacity: 0 }}
                                    animate={{ opacity: 1 }}
                                    className="completion-overlay active"
                                >
                                    <div className="success-icon">âœ“</div>
                                    <h2>Chapter {submission.chapter} Complete!</h2>
                                    <p>
                                        Your responses have been saved to your local machine, and Dr. Mora has been notified.
                                    </p>
                                    <button className="btn-primary" onClick={() => window.location.reload()}>
                                        Close App
                                    </button>
                                </motion.div>
                            )}
                        </AnimatePresence>
                    </main>
                    <input type="file" id="fileInput" ref={fileInputRef} style={{ display: 'none' }} onChange={handleFileChange} accept="image/*,.txt,.md" />
                    {
                        view === 'chat' && (
                            <div className="input-fixed-container">
                                <div className="input-box-wrapper">

                                    <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                                        <textarea
                                            ref={inputRef}
                                            className="input-box"
                                            rows={1}
                                            placeholder={isProcessing ? "Processing..." : "Type your response..."}
                                            value={inputValue}
                                            onChange={(e) => {
                                                setInputValue(e.target.value);
                                                adjustTextareaHeight();
                                            }}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter' && !e.shiftKey) {
                                                    e.preventDefault();
                                                    handleSend();
                                                }
                                            }}
                                            disabled={isProcessing || isSystemLocked}
                                            style={{ marginBottom: '2px' }}
                                        />
                                        <div style={{ fontSize: '0.75rem', color: '#5b6b7f', display: 'flex', alignItems: 'center', marginTop: '4px' }}>
                                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" style={{ marginRight: '2px' }}>
                                                <polyline points="18 15 12 9 6 15"></polyline>
                                            </svg>
                                            <select
                                                value={selectedModel}
                                                onChange={(e) => {
                                                    setSelectedModel(e.target.value);
                                                    localStorage.setItem('iStudy_preferred_model', e.target.value);
                                                }}
                                                style={{
                                                    appearance: 'none',
                                                    border: 'none',
                                                    background: 'transparent',
                                                    color: 'inherit',
                                                    fontSize: 'inherit',
                                                    fontWeight: '400',
                                                    cursor: 'pointer',
                                                    outline: 'none',
                                                    fontFamily: 'inherit',
                                                    paddingRight: '0'
                                                }}
                                            >
                                                <option value="gemini-3-flash-preview">Gemini 3 Flash</option>
                                                <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                                            </select>
                                        </div>
                                    </div>
                                    <button className="action-btn" onClick={handleVoiceInput} disabled={isProcessing} title="Dictate Response">ðŸŽ¤</button>
                                    <button className="action-btn send-btn" onClick={handleSend} disabled={isProcessing}>âž¤</button>
                                </div>
                            </div>
                        )
                    }
                    {
                        showSettings && (
                            <div className="settings-overlay">
                                <div className="settings-modal">
                                    <h2>Google AI Settings</h2>
                                    <div className="modal-content">
                                        <p>This application requires a Google AI API key to function. Your key is stored locally in your browser and is never sent to our servers.</p>

                                        {/* SAVED KEYS LIST */}
                                        {apiKeys.length > 0 && (
                                            <div className="saved-keys-section" style={{ marginBottom: '15px', padding: '10px', background: '#f0f9ff', borderRadius: '6px', border: '1px solid #e0f2fe' }}>
                                                <h4 style={{ margin: '0 0 8px 0', fontSize: '0.9em', color: '#0369a1' }}>Active Keys (Vault)</h4>
                                                <div style={{ maxHeight: '100px', overflowY: 'auto' }}>
                                                    {apiKeys.map((k, i) => (
                                                        <div key={i} style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.85em', padding: '4px 0', borderBottom: '1px solid #e0f2fe' }}>
                                                            <span><strong>{k.label}</strong>: {k.key.substring(0, 8)}...</span>
                                                            <span onClick={() => handleRemoveKey(i)} style={{ cursor: 'pointer', color: 'red', fontWeight: 'bold' }}>âœ•</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}

                                        <div className="api-input-group">
                                            <label>Google API Key</label>
                                            <input
                                                type="password"
                                                className="input-box"
                                                placeholder="Paste your key here..."
                                                value={tempKey}
                                                onChange={(e) => setTempKey(e.target.value)}
                                            />

                                            {/* Extra key inputs */}
                                            {extraKeys.map((key, idx) => (
                                                <input
                                                    key={idx}
                                                    type="password"
                                                    className="input-box"
                                                    style={{ marginTop: '8px' }}
                                                    placeholder={`Paste key #${idx + 2} here...`}
                                                    value={key}
                                                    onChange={(e) => {
                                                        const updated = [...extraKeys];
                                                        updated[idx] = e.target.value;
                                                        setExtraKeys(updated);
                                                    }}
                                                />
                                            ))}

                                            <div style={{ marginTop: '8px', textAlign: 'right' }}>
                                                <a
                                                    href="#"
                                                    onClick={(e) => { e.preventDefault(); setExtraKeys([...extraKeys, '']); }}
                                                    style={{ fontSize: '0.85em', color: 'var(--primary)', textDecoration: 'none' }}
                                                >
                                                    + Add one more key
                                                </a>
                                            </div>
                                        </div>

                                        <div className="instructions" style={{ marginBottom: '20px', paddingRight: '10px' }}>
                                            <p style={{ fontWeight: '600', marginBottom: '8px', color: 'var(--slate-800)' }}>How to get your API Key:</p>
                                            <ol style={{ paddingLeft: '20px', fontSize: '13px', color: 'var(--slate-600)' }}>
                                                <li style={{ marginBottom: '8px' }}>Go to <a href="https://aistudio.google.com/" target="_blank" style={{ color: 'var(--primary)' }}>Google AI Studio</a>.</li>
                                                <li style={{ marginBottom: '8px' }}>Click on "Projects", then on "+ Create a new project", name your project <strong>GEO309</strong>, and click "Create project".</li>
                                                <li style={{ marginBottom: '8px' }}>Click on "Get API key", then on "Create API key", name your key "GEO309", select the project you just created, and click "Create key".</li>
                                                <li style={{ marginBottom: '8px' }}>Copy the key.</li>
                                                <li style={{ marginBottom: '8px' }}>Paste that key here and click Save Key.</li>
                                            </ol>
                                            <p style={{ fontSize: '13px', color: 'var(--slate-600)', marginTop: '12px', fontStyle: 'italic' }}>
                                                You can add multiple keys from different email accounts to avoid quota limits! Simply repeat steps 1 to 5 using different emails.
                                            </p>
                                        </div>
                                    </div>

                                    <div className="modal-actions">
                                        <button className="btn-secondary" onClick={() => setShowSettings(false)}>Cancel</button>
                                        <button className="btn-primary" onClick={handleAddKeys}>Save Key</button>
                                    </div>
                                </div>
                            </div>
                        )
                    }
                    <footer className="landing-footer">
                        IStudy is an AI-powered essay review developed by <a href="https://github.com/Camilo-Mora" target="_blank">Camilo Mora, Ph.D.</a>
                    </footer>
                </div >
            );
        }
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>

</html>